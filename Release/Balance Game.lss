
AVRASM ver. 2.1.51  D:\caltech\ee10b\Balance Game\main.asm Sun Jun 16 13:54:31 2024

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\AVR Studio 5.1\extensions\Atmel\AVRAssembler\2.1.51.17\AvrAssembler/Include\m64def.inc'
D:\caltech\ee10b\Balance Game\main.asm(24): Including file 'C:\Program Files (x86)\Atmel\AVR Studio 5.1\extensions\Atmel\AVRAssembler\2.1.51.17\AvrAssembler/Include\m64def.inc'
D:\caltech\ee10b\Balance Game\main.asm(26): Including file 'D:\caltech\ee10b\Balance Game\chiptimerdefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(27): Including file 'D:\caltech\ee10b\Balance Game\displaydefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(28): Including file 'D:\caltech\ee10b\Balance Game\gamesettingdefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(29): Including file 'D:\caltech\ee10b\Balance Game\gametimerdefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(30): Including file 'D:\caltech\ee10b\Balance Game\generaldefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(31): Including file 'D:\caltech\ee10b\Balance Game\imudefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(32): Including file 'D:\caltech\ee10b\Balance Game\iodefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(33): Including file 'D:\caltech\ee10b\Balance Game\musicdefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(34): Including file 'D:\caltech\ee10b\Balance Game\randomdefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(35): Including file 'D:\caltech\ee10b\Balance Game\sounddefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(36): Including file 'D:\caltech\ee10b\Balance Game\switchdefs.inc'
D:\caltech\ee10b\Balance Game\main.asm(37): Including file 'D:\caltech\ee10b\Balance Game\timer.inc'
D:\caltech\ee10b\Balance Game\main.asm(132): Including file 'D:\caltech\ee10b\Balance Game\timer.asm'
D:\caltech\ee10b\Balance Game\main.asm(133): Including file 'D:\caltech\ee10b\Balance Game\chiptimer.asm'
D:\caltech\ee10b\Balance Game\main.asm(134): Including file 'D:\caltech\ee10b\Balance Game\display.asm'
D:\caltech\ee10b\Balance Game\main.asm(135): Including file 'D:\caltech\ee10b\Balance Game\div.asm'
D:\caltech\ee10b\Balance Game\main.asm(136): Including file 'D:\caltech\ee10b\Balance Game\game.asm'
D:\caltech\ee10b\Balance Game\main.asm(137): Including file 'D:\caltech\ee10b\Balance Game\gamedisplay.asm'
D:\caltech\ee10b\Balance Game\main.asm(138): Including file 'D:\caltech\ee10b\Balance Game\gametimer.asm'
D:\caltech\ee10b\Balance Game\main.asm(139): Including file 'D:\caltech\ee10b\Balance Game\imu.asm'
D:\caltech\ee10b\Balance Game\main.asm(140): Including file 'D:\caltech\ee10b\Balance Game\io.asm'
D:\caltech\ee10b\Balance Game\main.asm(141): Including file 'D:\caltech\ee10b\Balance Game\menu.asm'
D:\caltech\ee10b\Balance Game\main.asm(142): Including file 'D:\caltech\ee10b\Balance Game\music.asm'
D:\caltech\ee10b\Balance Game\main.asm(143): Including file 'D:\caltech\ee10b\Balance Game\random.asm'
D:\caltech\ee10b\Balance Game\main.asm(144): Including file 'D:\caltech\ee10b\Balance Game\segtable.asm'
D:\caltech\ee10b\Balance Game\main.asm(145): Including file 'D:\caltech\ee10b\Balance Game\sound.asm'
D:\caltech\ee10b\Balance Game\main.asm(146): Including file 'D:\caltech\ee10b\Balance Game\spi.asm'
D:\caltech\ee10b\Balance Game\main.asm(147): Including file 'D:\caltech\ee10b\Balance Game\switch.asm'
                 
                 ;-------------------------------------------------------------------------------
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega64.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m64def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega64
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega64
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M64DEF_INC_
                 #define _M64DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega64
                 #pragma AVRPART ADMIN PART_NAME ATmega64
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x96
                 .equ	SIGNATURE_002	= 0x02
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x8e	; MEMORY MAPPED
                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                 .equ	PING	= 0x63	; MEMORY MAPPED
                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	XDIV	= 0x3c
                 .equ	EICRB	= 0x3a
                 .equ	EIMSK	= 0x39
                 .equ	EIFR	= 0x38
                 .equ	TIMSK	= 0x37
                 .equ	TIFR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OCR0	= 0x31
                 .equ	ASSR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	OCDR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	SFIOR	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR0	= 0x0c
                 .equ	UCSR0A	= 0x0b
                 .equ	UCSR0B	= 0x0a
                 .equ	UBRR0L	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	PORTE	= 0x03
                 .equ	DDRE	= 0x02
                 .equ	PINE	= 0x01
                 .equ	PINF	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADFR	= ADATE	; For compatibility
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	UCSZ2	= UCSZ02	; For compatibility
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL0	= 6	; USART Mode Select
                 
                 ; UBRR0H - USART Baud Rate Register Hight Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** USART1 ***********************
                 ; UDR1 - USART I/O Data Register
                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR1A - USART Control and Status Register A
                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                 .equ	U2X1	= 1	; Double the USART transmission speed
                 .equ	UPE1	= 2	; Parity Error
                 .equ	DOR1	= 3	; Data overRun
                 .equ	FE1	= 4	; Framing Error
                 .equ	UDRE1	= 5	; USART Data Register Empty
                 .equ	TXC1	= 6	; USART Transmitt Complete
                 .equ	RXC1	= 7	; USART Receive Complete
                 
                 ; UCSR1B - USART Control and Status Register B
                 .equ	TXB81	= 0	; Transmit Data Bit 8
                 .equ	RXB81	= 1	; Receive Data Bit 8
                 .equ	UCSZ12	= 2	; Character Size
                 .equ	TXEN1	= 3	; Transmitter Enable
                 .equ	RXEN1	= 4	; Receiver Enable
                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR1C - USART Control and Status Register C
                 .equ	UCPOL1	= 0	; Clock Polarity
                 .equ	UCSZ10	= 1	; Character Size
                 .equ	UCSZ11	= 2	; Character Size
                 .equ	USBS1	= 3	; Stop Bit Select
                 .equ	UPM10	= 4	; Parity Mode Bit 0
                 .equ	UPM11	= 5	; Parity Mode Bit 1
                 .equ	UMSEL1	= 6	; USART Mode Select
                 
                 ; UBRR1H - USART Baud Rate Register Hight Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR1L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	SM2	= 2	; Sleep Mode Select
                 .equ	SM0	= 3	; Sleep Mode Select
                 .equ	SM1	= 4	; Sleep Mode Select
                 .equ	SE	= 5	; Sleep Enable
                 .equ	SRW10	= 6	; External SRAM Wait State Select
                 .equ	SRE	= 7	; External SRAM Enable
                 
                 ; XMCRA - External Memory Control Register A
                 .equ	SRW11	= 1	; Wait state select bit upper page
                 .equ	SRW00	= 2	; Wait state select bit lower page
                 .equ	SRW01	= 3	; Wait state select bit lower page
                 .equ	SRL0	= 4	; Wait state page limit
                 .equ	SRL1	= 5	; Wait state page limit
                 .equ	SRL2	= 6	; Wait state page limit
                 
                 ; XMCRB - External Memory Control Register B
                 .equ	XMM0	= 0	; External Memory High Mask
                 .equ	XMM1	= 1	; External Memory High Mask
                 .equ	XMM2	= 2	; External Memory High Mask
                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value
                 .equ	CAL1	= 1	; Oscillator Calibration Value
                 .equ	CAL2	= 2	; Oscillator Calibration Value
                 .equ	CAL3	= 3	; Oscillator Calibration Value
                 .equ	CAL4	= 4	; Oscillator Calibration Value
                 .equ	CAL5	= 5	; Oscillator Calibration Value
                 .equ	CAL6	= 6	; Oscillator Calibration Value
                 .equ	CAL7	= 7	; Oscillator Calibration Value
                 
                 ; XDIV - XTAL Divide Control Register
                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMCR	= SPMCSR	; For compatibility
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write section read enable
                 .equ	ASRE	= RWWSRE	; For compatibility
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	ASB	= RWWSB	; For compatibility
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** JTAG *************************
                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                 .equ	IDRD	= OCDR7	; For compatibility
                 
                 ; MCUCSR - MCU Control And Status Register
                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                 ;.equ	JTD	= 7	; JTAG Interface Disable
                 
                 
                 ; ***** MISC *************************
                 ; SFIOR - Special Function IO Register
                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                 .equ	PSR1	= PSR321	; For compatibility
                 .equ	PSR2	= PSR321	; For compatibility
                 .equ	PSR3	= PSR321	; For compatibility
                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                 .equ	PUD	= 2	; Pull Up Disable
                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                 
                 ; EICRB - External Interrupt Control Register B
                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	GICR	= EIMSK	; For compatibility
                 .equ	GIMSK	= EIMSK	; For compatibility
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	GIFR	= EIFR	; For compatibility
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 .equ	INTF2	= 2	; External Interrupt Flag 2
                 .equ	INTF3	= 3	; External Interrupt Flag 3
                 .equ	INTF4	= 4	; External Interrupt Flag 4
                 .equ	INTF5	= 5	; External Interrupt Flag 5
                 .equ	INTF6	= 6	; External Interrupt Flag 6
                 .equ	INTF7	= 7	; External Interrupt Flag 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** PORTE ************************
                 ; PORTE - Data Register, Port E
                 .equ	PORTE0	= 0	; 
                 .equ	PE0	= 0	; For compatibility
                 .equ	PORTE1	= 1	; 
                 .equ	PE1	= 1	; For compatibility
                 .equ	PORTE2	= 2	; 
                 .equ	PE2	= 2	; For compatibility
                 .equ	PORTE3	= 3	; 
                 .equ	PE3	= 3	; For compatibility
                 .equ	PORTE4	= 4	; 
                 .equ	PE4	= 4	; For compatibility
                 .equ	PORTE5	= 5	; 
                 .equ	PE5	= 5	; For compatibility
                 .equ	PORTE6	= 6	; 
                 .equ	PE6	= 6	; For compatibility
                 .equ	PORTE7	= 7	; 
                 .equ	PE7	= 7	; For compatibility
                 
                 ; DDRE - Data Direction Register, Port E
                 .equ	DDE0	= 0	; 
                 .equ	DDE1	= 1	; 
                 .equ	DDE2	= 2	; 
                 .equ	DDE3	= 3	; 
                 .equ	DDE4	= 4	; 
                 .equ	DDE5	= 5	; 
                 .equ	DDE6	= 6	; 
                 .equ	DDE7	= 7	; 
                 
                 ; PINE - Input Pins, Port E
                 .equ	PINE0	= 0	; 
                 .equ	PINE1	= 1	; 
                 .equ	PINE2	= 2	; 
                 .equ	PINE3	= 3	; 
                 .equ	PINE4	= 4	; 
                 .equ	PINE5	= 5	; 
                 .equ	PINE6	= 6	; 
                 .equ	PINE7	= 7	; 
                 
                 
                 ; ***** PORTF ************************
                 ; PORTF - Data Register, Port F
                 .equ	PORTF0	= 0	; 
                 .equ	PF0	= 0	; For compatibility
                 .equ	PORTF1	= 1	; 
                 .equ	PF1	= 1	; For compatibility
                 .equ	PORTF2	= 2	; 
                 .equ	PF2	= 2	; For compatibility
                 .equ	PORTF3	= 3	; 
                 .equ	PF3	= 3	; For compatibility
                 .equ	PORTF4	= 4	; 
                 .equ	PF4	= 4	; For compatibility
                 .equ	PORTF5	= 5	; 
                 .equ	PF5	= 5	; For compatibility
                 .equ	PORTF6	= 6	; 
                 .equ	PF6	= 6	; For compatibility
                 .equ	PORTF7	= 7	; 
                 .equ	PF7	= 7	; For compatibility
                 
                 ; DDRF - Data Direction Register, Port F
                 .equ	DDF0	= 0	; 
                 .equ	DDF1	= 1	; 
                 .equ	DDF2	= 2	; 
                 .equ	DDF3	= 3	; 
                 .equ	DDF4	= 4	; 
                 .equ	DDF5	= 5	; 
                 .equ	DDF6	= 6	; 
                 .equ	DDF7	= 7	; 
                 
                 ; PINF - Input Pins, Port F
                 .equ	PINF0	= 0	; 
                 .equ	PINF1	= 1	; 
                 .equ	PINF2	= 2	; 
                 .equ	PINF3	= 3	; 
                 .equ	PINF4	= 4	; 
                 .equ	PINF5	= 5	; 
                 .equ	PINF6	= 6	; 
                 .equ	PINF7	= 7	; 
                 
                 
                 ; ***** PORTG ************************
                 ; PORTG - Data Register, Port G
                 .equ	PORTG0	= 0	; 
                 .equ	PG0	= 0	; For compatibility
                 .equ	PORTG1	= 1	; 
                 .equ	PG1	= 1	; For compatibility
                 .equ	PORTG2	= 2	; 
                 .equ	PG2	= 2	; For compatibility
                 .equ	PORTG3	= 3	; 
                 .equ	PG3	= 3	; For compatibility
                 .equ	PORTG4	= 4	; 
                 .equ	PG4	= 4	; For compatibility
                 
                 ; DDRG - Data Direction Register, Port G
                 .equ	DDG0	= 0	; 
                 .equ	DDG1	= 1	; 
                 .equ	DDG2	= 2	; 
                 .equ	DDG3	= 3	; 
                 .equ	DDG4	= 4	; 
                 
                 ; PING - Input Pins, Port G
                 .equ	PING0	= 0	; 
                 .equ	PING1	= 1	; 
                 .equ	PING2	= 2	; 
                 .equ	PING3	= 3	; 
                 .equ	PING4	= 4	; 
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0 - Timer/Counter Control Register
                 .equ	CS00	= 0	; Clock Select 0
                 .equ	CS01	= 1	; Clock Select 1
                 .equ	CS02	= 2	; Clock Select 2
                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                 .equ	CTC0	= WGM01	; For compatibility
                 .equ	COM00	= 4	; Compare match Output Mode 0
                 .equ	COM01	= 5	; Compare Match Output Mode 1
                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                 .equ	PWM0	= WGM00	; For compatibility
                 .equ	FOC0	= 7	; Force Output Compare
                 
                 ; TCNT0 - Timer/Counter Register
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0 - Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; ASSR - Asynchronus Status Register
                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0	= 1	; Output Compare Flag 0
                 
                 ; SFIOR - Special Function IO Register
                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                 
                 ; SFIOR - Special Function IO Register
                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Clock Select bit 0
                 .equ	CS11	= 1	; Clock Select 1 bit 1
                 .equ	CS12	= 2	; Clock Select1 bit 2
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TCCR2 - Timer/Counter Control Register
                 .equ	CS20	= 0	; Clock Select
                 .equ	CS21	= 1	; Clock Select
                 .equ	CS22	= 2	; Clock Select
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Match Output Mode
                 .equ	COM21	= 5	; Compare Match Output Mode
                 .equ	WGM20	= 6	; Wafeform Generation Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter Register
                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; OCR2 - Output Compare Register
                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                 
                 ; TIMSK - 
                 .equ	TOIE2	= 6	; 
                 .equ	OCIE2	= 7	; 
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 
                 ; ***** TIMER_COUNTER_3 **************
                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                 
                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                 .equ	ICF3	= 5	; Input Capture Flag 1
                 
                 ; SFIOR - Special Function IO Register
                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                 ;.equ	PSR1	= PSR321	; For compatibility
                 ;.equ	PSR2	= PSR321	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 ; TCCR3A - Timer/Counter3 Control Register A
                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                 .equ	PWM30	= WGM30	; For compatibility
                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                 .equ	PWM31	= WGM31	; For compatibility
                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                 
                 ; TCCR3B - Timer/Counter3 Control Register B
                 .equ	CS30	= 0	; Clock Select 3 bit 0
                 .equ	CS31	= 1	; Clock Select 3 bit 1
                 .equ	CS32	= 2	; Clock Select3 bit 2
                 .equ	WGM32	= 3	; Waveform Generation Mode
                 .equ	CTC30	= WGM32	; For compatibility
                 .equ	WGM33	= 4	; Waveform Generation Mode
                 .equ	CTC31	= WGM33	; For compatibility
                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                 
                 ; TCCR3C - Timer/Counter3 Control Register C
                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                 
                 ; TCNT3L - Timer/Counter3 Low Byte
                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 ; EXTENDED fuse bits
                 .equ	WDTON	= 0	; Watchdog timer always on
                 .equ	CompMode	= 1	; Compabillity mode
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x7fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 4096
                 .equ	RAMEND	= 0x10ff
                 .equ	XRAMEND	= 0xffff
                 .equ	E2END	= 0x07ff
                 .equ	EEPROMEND	= 0x07ff
                 .equ	EEADRBITS	= 11
                 #pragma AVRPART MEMORY PROG_FLASH 65536
                 #pragma AVRPART MEMORY EEPROM 2048
                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x7000
                 .equ	NRWW_STOP_ADDR	= 0x7fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x6fff
                 .equ	PAGESIZE	= 128
                 .equ	FIRSTBOOTSTART	= 0x7e00
                 .equ	SECONDBOOTSTART	= 0x7c00
                 .equ	THIRDBOOTSTART	= 0x7800
                 .equ	FOURTHBOOTSTART	= 0x7000
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                 
                 #endif  /* _M64DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ; File:             main.asm
                 ; Description:      This program provides the main loop for the ball balance
                 ;                   game, the final project for EE 10b. The program initializes
                 ;                   the hardware, and then enters the main loop.
                 ;
                 ; Input:            None.
                 ; Output:           Music on the speaker, display on the game and 7-segment LEDs,
                 ;
                 ; User Interface:   None.
                 ; Error Handling:   None.
                 ;
                 ; Algorithms:       None.
                 ; Data Structures:  None.
                 ;
                 ; Known Bugs:       None.
                 ; Limitations:      None.
                 ;
                 ; Revision History: 2024/06/01 - Initial Revision
                 ;-------------------------------------------------------------------------------
                 
                 ; device setup and include files
                 .device ATMEGA64
                 .include "m64def.inc"
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega64.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m64def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega64
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega64
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M64DEF_INC_
                 #endif  /* _M64DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 .include "chiptimerdefs.inc"
                 
                 ; File:             timerdefs.inc
                 ; Description:      This file contains definitions for clock prescaling
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 2024/05/16 - Initial revision
                 ;                   2024/05/18 - Debug and test
                 ;                   2024/06/01 - Remove extra definitions
                 ;-------------------------------------------------------------------------------
                 
                 
                 .equ    TIMER_CLK_STOP    = 0b00000000	;stop the timer
                 .equ    TIMER_CLK_1       = 0b00000001	;timer runs at CLK
                 .equ    TIMER_CLK_8       = 0b00000010	;timer runs at CLK/8
                 .equ    TIMER_CLK_64      = 0b00000011	;timer runs at CLK/64
                 .equ    TIMER_CLK_255     = 0b00000100	;timer runs at CLK/256
                 .equ    TIMER_CLK_1024    = 0b00000101	;timer runs at CLK/1024
                 .include "displaydefs.inc"
                 
                 ; File:             displaydefs.inc
                 ; Description:      This file contains the definitions for the display routines.
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 5/16/2024 - Initial revision
                 ;                   5/18/2024 - Debug and test
                 ;-------------------------------------------------------------------------------
                 
                 
                 .equ    LOW_HEX_DIG         = 0x0F  ; mask for low nibble
                 .equ    HIGH_HEX_DIG        = 0xF0  ; mask for high nibble
                 
                 .equ    DISP_BUFF_LEN       = 14    ; length of display buffer
                 
                 .equ    LED_OFF             = 0x00  ; LED off pattern for GPIO port
                 
                 .equ    DISP_ON_T_INIT      = 1     ; display on time (max 255)
                 .equ    DISP_OFF_T_INIT     = 0     ; display off time (max 255)
                 
                 .equ    SEG_BUF_OFFSET      = 10    ; offset of 7-segment in the main buffer
                 .equ    MODE_BTN_IDX        = 71    ; index for mode button
                 .equ    START_BTN_IDX       = 72    ; index for start button
                 
                 .equ    GAME_LED_IDX_MAX    = 70    ; maximum game LED index
                 .equ    LED_IDX_MAX         = 72    ; maximum game LED index
                 .include "gamesettingdefs.inc"
                 
                 .equ START_POS                  = MIDDLE_LED
                 
                 .equ TIMED                      = 0xff
                 .equ INFINITE                   = 0xfe
                 .equ WIN                        = 0x0f
                 .equ LOSE                       = 0x1f
                 .equ BLINK_TIME                 = 127
                 
                 .equ BALL_POS_FRAC_MAX          = 10      ; decimal system
                 
                 .EQU GRAVITY        = 0
                 .EQU GRAV_UB        = 4
                 .EQU GRAV_LB        = 1
                 .equ GRAV_INIT      = 1
                 
                 .EQU F_INVIS        = 1
                 .EQU F_INVIS_UB     = 7
                 .EQU F_INVIS_LB     = 0
                 .equ F_INVIS_INIT   = 0
                 
                 .EQU BOUND          = 2
                 .EQU BOUND_UB       = 35
                 .EQU BOUND_LB       = 10
                 .equ BOUND_INIT     = BOUND_UB
                 
                 .EQU RANDOM_V       = 3
                 .EQU RANDOM_V_UB    = 4
                 .EQU RANDOM_V_LB    = 0
                 .equ RANDOM_V_INIT  = 0
                 
                 .EQU TIME_LIM      = 4
                 .EQU TIME_LIM_UB   = 0xff
                 .EQU TIME_LIM_LB   = 1
                 .equ TIME_LIM_INIT = 10
                 
                 .EQU SIZE           = 5
                 .EQU SIZE_UB		= 3
                 .EQU SIZE_LB		= 1
                 .equ SIZE_INIT		= 1
                 
                 .EQU MAX_SETTING_IDX = SIZE
                 
                 .include "gametimerdefs.inc"
                 
                 .equ GAME_TIMER_PERIOD          = 1000   ; every second
                 .equ STATUS_TIMER_IDX           = 1
                 .equ STATUS_TIMER_PERIOD        = 100  ; 10 Hz update
                 .equ RANDOM_EVENT_TIMER_IDX     = 2
                 .equ RANDOM_EVENT_TIMER_PERIOD  = 1000 ; every second
                 .equ SOUND_TIMER_IDX            = 3
                 .include "generaldefs.inc"
                 
                 ; File:             generaldef.inc
                 ; Description:      This file contains general definitions and macros.
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 5/16/2024 - Initial revision
                 ;                   6/01/2024 - Add general macros
                 ;-------------------------------------------------------------------------------
                 
                 
                 .EQU	TRUE		= 0b00000001    ; boolean true
                 .EQU	FALSE   	= 0b00000000    ; boolean false
                 .EQU    MOD_8       = 0b00000111    ; and with this constant to perform modulo 8
                 
                 
                 ; Macro: byteTabOffsetY
                 ; Description:          This macro calculates the offset of a byte table and sets the Y
                 ;                       register to the address of the table plus the offset.
                 ; Operation:            Y = @0 + @1
                 ; 
                 ; Arguments:            @0 - the table address
                 ;                       @1 - the offset
                 ; Return Value:         Y register set to the address of the table plus the offset
                 ;
                 ; Global Variables:     YL, YH
                 ; Shared Variables:     None.
                 ; Local Variables:      zero register (r0)
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    Y.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/16/2024
                 
                 .macro      byteTabOffsetY
                     push    r0
                     ldi     YL, low(@0)
                     ldi     YH, high(@0)
                     add     YL, @1
                     clr     r0
                     adc     YH, r0
                     pop     r0
                 .endmacro
                 
                 
                 
                 ; Macro: wordTabOffsetZ
                 ; Description:          This macro calculates the offset of a word table and 
                 ;                       sets the Z register to the address of the table + offset.
                 ; Operation:            Z = 2 * @0 + @1
                 ;
                 ; Arguments:            @0 - the table address
                 ;                       @1 - the offset
                 ; Return Value:         Z register set to the address of the table plus the offset
                 ;
                 ; Global Variables:     ZL, ZH
                 ; Shared Variables:     None.
                 ; Local Variables:      zero register (r0)
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    Z.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/16/2024
                 
                 .macro      wordTabOffsetZ
                     push r0
                     ldi     ZL, low(2 * @0)
                     ldi     ZH, high(2 * @0)
                     add     ZL, @1
                     clr     r0
                     adc     ZH, r0
                     pop r0
                 .include "imudefs.inc"
                 
                 ; File:             imudefs.inc
                 ; Description:      This file contains definitions for IMU setup and communication.
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 2024/06/01 - Initial revision
                 ;-------------------------------------------------------------------------------
                 
                 #ifndef IMUDEFS_INC ; include guard since test code also includes this file
                 #define IMUDEFS_INC
                 
                 ; IMU accelerometer register addresses
                 .equ IMU_AX_HIGH            = 59
                 .equ IMU_AX_LOW             = 60
                 .equ IMU_AY_HIGH            = 61
                 .equ IMU_AY_LOW             = 62
                 .equ IMU_AZ_HIGH            = 63
                 .equ IMU_AZ_LOW             = 64
                 
                 ; Patterns for reading and writing to the IMU
                 .equ IMU_READ               = 0x80  ; OR with register address to read
                 .equ IMU_READ_IGNORE        = 0xFF  ; second byte sent to IMU when reading
                 
                 ; IMU configuration registers
                 .equ IMU_GENERAL_CONFIG     = 26
                 .equ IMU_ACCEL_CONFIG0      = 28
                 .equ IMU_ACCEL_CONFIG1      = 29
                 .equ IMU_CONFIG_RESET       = 0x00
                 
                 
                 ; Macro: GetAccel
                 ; Description:          This macro reads the accelerometer data from the IMU and
                 ;                       stores it in r17|r16.
                 ; Operation:            Reads the high byte of the accelerometer data into r17,
                 ;                       then reads the low byte into r16.
                 ; 
                 ; Arguments:            @0 - the register address of the high byte
                 ;                       @1 - the register address of the low byte
                 ; Return Value:         r17|r16 - the accelerometer data, fixed point from -2 to
                 ;                       2 g. 
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16, r17
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        2024/06/01
                 
                 .macro GetAccel
                     ldi r16, @0
                     rcall IMURead
                     mov r17, r16
                     ldi r16, @1
                     rcall IMURead
                 .endm
                 
                 #endif ; IMUDEFS_INC
                 .include "iodefs.inc"
                 
                 ; File:             iodefs.inc
                 ; Description:      This file contains the definitions related to IO setup.
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 5/16/2024 - Initial revision
                 ;                   5/18/2024 - Debug and test
                 ;                   6/1/2024 - Add SPI and speaker definitions
                 ;-------------------------------------------------------------------------------
                 
                 ; I/O port data direction register definitions
                 .equ	OUTDATA		        = 0b11111111
                 .equ    INDATA		        = 0b00000000
                 
                 ; display definitions
                 .equ    DISP_SINK_PORT_DDR  = DDRC
                 .equ    DISP_SRC_PORT0_DDR  = DDRA
                 .equ    DISP_SRC_PORT1_DDR  = DDRD
                 .equ    DISP_SINK_PORT      = PORTC
                 .equ    DISP_SRC_PORT0      = PORTA
                 .equ    DISP_SRC_PORT1      = PORTD
                 .equ    SEG_MSG_LENGTH      = 4
                 
                 ; Speaker definitions
                 .equ    SPEAKER_PORT        = PORTB
                 .equ    SPEAKER_PORT_DDR    = DDRB
                 .equ    SPEAKER_PIN         = 5
                 
                 ; SPI definitions
                 .equ    SPI_PORT            = PORTB
                 .equ    SPI_PORT_DDR        = DDRB
                 .equ    SPI_SS_PIN          = 0
                 .equ    SPI_SCK_PIN         = 1
                 .equ    SPI_MOSI_PIN        = 2
                 .equ    SPI_MISO_PIN        = 3
                 
                 ; IMU definitions
                 .equ    IMU_PORT            = SPI_PORT
                 .include "musicdefs.inc"
                 
                     in      r17, SREG
                     cli     
                     ldi     r16, low(@0)
                     sts     curr_sequence, r16
                     ldi     r16, high(@0)
                     sts     curr_sequence+1, r16
                     out     SREG, r17
                 .include "randomdefs.inc"
                 .include "sounddefs.inc"
                 
                 ; File:             sounddefs.inc
                 ; Description:      This file contains definitions for sound generation
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 2024/06/01 - Initial revision
                 ;-------------------------------------------------------------------------------
                 
                 
                 ; frequency that the speaker will be turned off
                 .equ FREQ_OFF   = 0x00
                 
                 ; Timer 1 frequency for division = 8 MHz / 64(prescaler) / 2 = 62.5 kHz = 0xF424
                 .include "switchdefs.inc"
                 
                 ; Description:      This file contains definitions for the switch inputs
                 ;                   and the debouncing constants
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 2024/05/03 - Gavin Hua - Initial Revision
                 ;                   2024/05/04 - Gavin Hua - Added constants for auto-repeat
                 ;                   2024/06/09 - Gavin Hua - Remove extra definitions
                 ;-------------------------------------------------------------------------------
                 
                 
                 .EQU    BUTTON_DATA         = PINE          ;button data register
                 
                 .EQU    DEBOUNCE_T          = 10            ; debounce time in interrupt ticks
                 .EQU    AUTOREP_T           = 255           ; autorepeat time in interrupt ticks
                 
                 .EQU	START_BTN_MASK		= 0b10000000    ; mask for the start button
                 .EQU	MODE_BTN_MASK		= 0b01000000    ; mask for the mode button
                 .EQU	ROT_BTN_MASK		= 0b00100000    ; mask for the rotary encoder
                 .EQU	ENC_MASK    		= 0b00011000    ; mask for the rotary encoder reading
                 
                 .EQU    ENC_INIT_STATE      = 0b00000000    ; initial history of encoder
                 .EQU    ENC_BOUNCE_MASK     = 0b00110000    ; mask for the encoder bounce
                 .EQU    ENC_PREV_MASK       = 0b11000000    ; mask for the previous encoder state
                 .EQU    ENC_CCW_TURN        = 0b11100001    ; state for counterclockwise turn
                 .include "timer.inc"
                 
                 ;                                                                            ;
                 ;                                   timer.inc                                ;
                 ;                          Timing Routines Include File                      ;
                 ;                                                                            ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 ; This file contains the definitions for the timing functions defined in
                 ; timer.asm.
                 ;
                 ; Revision History:
                 ;     9/30/13  Glen George      initial revision
                 ;     4/30/18  Glen George      updated comments
                 
                 
                 
                 
                 ;delay timer constants
                 .EQU	TIMER_CNT = 5			;number of delay timers
                 
                 ;-------------------------------------------------------------------------------
                 .cseg
                 
                 ; vector jump table
                 .org    $0000
000000 940c 0046     jmp     Start                   ;reset vector
000002 940c 0002     jmp     PC                      ;external interrupt 0
000004 940c 0004     jmp     PC                      ;external interrupt 1
000006 940c 0006     jmp     PC                      ;external interrupt 2
000008 940c 0008     jmp     PC                      ;external interrupt 3
00000a 940c 000a     jmp     PC                      ;external interrupt 4
00000c 940c 000c     jmp     PC                      ;external interrupt 5
00000e 940c 000e     jmp     PC                      ;external interrupt 6
000010 940c 0010     jmp     PC                      ;external interrupt 7
000012 940c 0012     jmp     PC                      ;timer 2 compare match
000014 940c 0014     jmp     PC                      ;timer 2 overflow
000016 940c 0016     jmp     PC                      ;timer 1 capture
000018 940c 0018     jmp     PC                      ;timer 1 compare match A
00001a 940c 001a     jmp     PC                      ;timer 1 compare match B
00001c 940c 001c     jmp     PC                      ;timer 1 overflow
00001e 940c 001e     jmp     PC                      ;timer 0 compare match
000020 940c 00a1     jmp     Timer0OverflowHandler   ;timer 0 overflow
000022 940c 0022     jmp     PC                      ;SPI transfer complete
000024 940c 0024     jmp     PC                      ;UART 0 Rx complete
000026 940c 0026     jmp     PC                      ;UART 0 Tx empty
000028 940c 0028     jmp     PC                      ;UART 0 Tx complete
00002a 940c 002a     jmp     PC                      ;ADC conversion complete
00002c 940c 002c     jmp     PC                      ;EEPROM ready
00002e 940c 002e     jmp     PC                      ;analog comparator
000030 940c 0030     jmp     PC                      ;timer 1 compare match C
000032 940c 0032     jmp     PC                      ;timer 3 capture
000034 940c 0034     jmp     PC                      ;timer 3 compare match A
000036 940c 0036     jmp     PC                      ;timer 3 compare match B
000038 940c 0038     jmp     PC                      ;timer 3 compare match C
00003a 940c 003a     jmp     PC                      ;timer 3 overflow
00003c 940c 003c     jmp     PC                      ;UART 1 Rx complete
00003e 940c 003e     jmp     PC                      ;UART 1 Tx empty
000040 940c 0040     jmp     PC                      ;UART 1 Tx complete
000042 940c 0042     jmp     PC                      ;Two-wire serial interface
000044 940c 0044     jmp     PC                      ;store program memory ready
                 
                 
                 ; main program
                 Start:                                 ; start the CPU after a reset
000046 e70f          ldi     r16, low(stack_top)        ; initialize the stack pointer
000047 bf0d          out     SPL, r16
000048 e001          ldi     r16, high(stack_top)
000049 bf0e          out     SPH, r16
                 
00004a d2d6          rcall   InitIO
00004b d045          rcall   InitChipTimers
00004c d012          rcall   InitTimers
00004d d423          rcall   InitRandom
00004e d097          rcall   InitDisplay
00004f d491          rcall   InitSound
000050 d4a3          rcall   InitSPI
000051 d2a7          rcall   InitIMU
000052 d177          rcall   InitGame
000053 d228          rcall   InitGameTimers
000054 d001          rcall   Main
000055 cff0          rjmp    Start                   ; shouldn't return, but if it does, restart
                 
                 
                 ;-------------------------------------------------------------------------------
                 
                 Main:
000056 9100 01a6     lds     r16, in_game
000058 3001          cpi     r16, TRUE
000059 f001          breq    CallGameLoop
                     ; brne   CallMenuLoop
                 
                 CallGameLoop:
00005a d183          rcall   GameLoop
00005b c002          rjmp    MainEnd
                 
                 CallMenuLoop:
00005c d2db          rcall   MenuLoop
00005d c000          rjmp    MainEnd
                 
                 MainEnd:
00005e cff7          rjmp    Main
                 
                 ;-------------------------------------------------------------------------------
                 ; stack space
                 .dseg
                 
000100                          .byte   127
00017f           stack_top:     .byte   1                  ; top of stack
                 
                 
                 
                 ;-------------------------------------------------------------------------------
                 ; include asm files for the rest of the program
                 .include "timer.asm"
                 
                 ;                                                                            ;
                 ;                                    TIMER                                   ;
                 ;                               Timing Routines                              ;
                 ;                                                                            ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 ; This file contains the general AVR timing functions.  The functions can be
                 ; used to create up to TIMER_CNT simultaneous timers.  It is assumed that the
                 ; TimerHandler function is called every millisecond to keep track of time.
                 ; The functions included are:
                 ;    DelayNotDone - a previously started delay is not done yet
                 ;    InitTimers   - initialize the timing system
                 ;    StartDelay   - start timing a delay (start a timer)
                 ;    TimerHandler - timer 0 overflow handler
                 ;
                 ; Revision History:
                 ;     1/25/10  Glen George              initial revision
                 ;     1/26/10  Glen George              now allow multiple delay timers
                 ;     1/31/10  Glen George              added frequency meter updates
                 ;     2/3/10   Glen George              updated comments
                 ;     8/22/10  Glen George              moved frequency meter checks into
                 ;					   frequency code
                 ;     7/23/12  Glen George              generalized the functions for use in
                 ;					   any program
                 ;     7/28/12  Glen George              updated comments
                 ;     9/30/13  Glen George              added inclusion of timer.inc
                 
                 
                 
                 ; local include files
                 ;.include  "timer.inc"
                 
                 
                 
                 
                 .cseg
                 
                 
                 
                 
                 ; InitTimers
                 ;
                 ; Description:       This function initializes the timing system.
                 ;
                 ; Operation:         This function initializes the variables for the timing
                 ;                    system.
                 ;
                 ; Arguments:         None.
                 ; Return Value:      None.
                 ;
                 ; Local Variables:   None.
                 ; Shared Variables:  delay_timer - written (all bytes reset to 0).
                 ; Global Variables:  None.
                 ;
                 ; Input:             None.
                 ; Output:            None.
                 ;
                 ; Error Handling:    None.
                 ;
                 ; Algorithms:        None.
                 ; Data Structures:   None.
                 ;
                 ; Registers Changed: flags, R16, R17, X (XH | XL)
                 ; Stack Depth:       0 bytes
                 ;
                 ; Author:            Glen George
                 ; Last Modified:     July 23, 2012
                 
                 InitTimers:
                 
00005f 2700      	CLR		R16			;clear the timer value
000060 2711      	CLR		R17			;and the timer counter
000061 e8a0      	LDI		XL, LOW(delay_timer)	;point to the timer data
000062 e0b1      	LDI		XH, HIGH(delay_timer)
                 
                 InitTimerLoop:				;loop setting all bytes to 0
000063 930d      	ST		X+, R16
000064 9513      	INC		R17			;count the timer bytes
000065 301a      	CPI		R17, 2 * TIMER_CNT	;there are 2 bytes per timer
000066 f3e0      	BRLO	InitTimerLoop		;loop while still have bytes to clear
                 	;BRSH	EndInitTimers		;if done setting up timers, done
                 
                 
                 EndInitTimers:                          ;done initializing the timers - return
000067 9508              RET
                 
                 
                 
                 
                 ; StartDelay
                 ;
                 ; Description:       This function starts a delay interval.  DelayNotDone will
                 ;                    return false after the passed number of milliseconds has
                 ;                    elapsed for the passed timer.  The passed timer number
                 ;                    must be valid (0 to TIMER_CNT - 1) or no timer is
                 ;                    started.  The maximum delay is 65.535 seconds.
                 ;
                 ; Operation:         The passed delay argument is stored in the appropriate
                 ;                    delay_timer element.
                 ;
                 ; Arguments:         R16 - the number of the timer to be started, must be
                 ;                          between 0 and TIMER_CNT - 1.
                 ;                    X   - the delay in milliseconds.
                 ; Return Value:      None.
                 ;
                 ; Local Variables:   None.
                 ; Shared Variables:  delay_timer - written (passed timer's count is changed).
                 ;
                 ; Input:             None.
                 ; Output:            None.
                 ;
                 ; Error Handling:    If the passed timer number is out of range, no timer is
                 ;                    changed.	
                 ;
                 ; Algorithms:        None.
                 ; Data Structures:   None.
                 ;
                 ; Registers Changed: flags, R16, Y (YH | YL)
                 ; Stack Depth:       0 bytes
                 ;
                 ; Author:            Glen George
                 ; Last Modified:     July 23, 2012
                 
                 StartDelay:
                 
                 CheckArgs:				;check the timer number
000068 3005      	CPI		R16, TIMER_CNT
000069 f440      	BRSH	EndStartDelay		;if out of range do nothing
                 	;BRLO	SetupDelayTimer		;otherwise setup the delay timer
                 
                 
                 SetupDelayTimer:			;setup the delay timer
00006a 0f00      	LSL		R16			;two bytes per timer
                 
00006b e8c0      	LDI		YL, LOW(delay_timer)	;get the address of the timer
00006c e0d1      	LDI		YH, HIGH(delay_timer)
00006d 0fc0      	ADD		YL, R16
00006e f408      	BRCC	DoneTimerCarry		;no carry to propagate
00006f 95d3      	INC		YH			;propagate carry
                 DoneTimerCarry:
000070 93a9      	ST		Y+, XL			;store the new delay time
000071 93b9      	ST		Y+, XH
                 
                 
                 EndStartDelay:				;done setting up delay, return
000072 9508              RET
                 
                 
                 
                 
                 ; DelayNotDone
                 ;
                 ; Description:       This function returns true if the delay time has not
                 ;                    passed since StartDelay was called for the passed timer
                 ;                    number (must be between 0 and TIMER_CNT - 1).  False is
                 ;                    returned if the delay has elapsed.
                 ;
                 ; Operation:         The function or's the bytes of the appropriate delay_timer
                 ;                    element into R0 which can then be checked for 0.
                 ;
                 ; Arguments:         R16 - the number of the timer to be checked, must be
                 ;                          between 0 and TIMER_CNT - 1.
                 ; Return Value:      R0 - true (non-zero) if the delay time has not elapsed
                 ;                         since StartDelay was called for this timer and false
                 ;                         (zero) if the delay time has elapsed.
                 ;                    ZF - set iff the delay time has elapsed for this timer.
                 ;
                 ; Local Variables:   None.
                 ; Shared Variables:  delay_timer - read only.
                 ; Global Variables:  None.
                 ;
                 ; Input:             None.
                 ; Output:            None.
                 ;
                 ; Error Handling:    If the timer number is out of range (greater than or
                 ;                    equal to TIMER_CNT), false is returned.
                 ;
                 ; Algorithms:        None.
                 ; Data Structures:   None.
                 ;
                 ; Registers Changed: flags, R0, R16, Y (YH | YL)
                 ; Stack Depth:       0 bytes
                 ;
                 ; Author:            Glen George
                 ; Last Modified:     August 22, 2010
                 
                 DelayNotDone:
                 
                 
                 CheckStatusArgs:			;check the timer number
000073 3005      	CPI	R16, TIMER_CNT
000074 f450      	BRSH	InvalidTimer		;handle out of range timer
                 	;BRLO	SetupTimerCheck		;otherwise setup to check the timer
                 
                 
                 SetupTimerCheck:			;setup to check the delay timer
000075 0f00      	LSL	R16			;two bytes per timer
                 
000076 e8c0      	LDI	YL, LOW(delay_timer)	;get the address of the timer
000077 e0d1      	LDI	YH, HIGH(delay_timer)
000078 0fc0      	ADD	YL, R16
000079 f408      	BRCC	CheckTimer		;no carry, check the timer
00007a 95d3      	INC	YH			;otherwise, propagate carry
                 	;RJMP	CheckTimer		;then check the timer
                 
                 
                 CheckTimer:				;check the timer
00007b 8009              LDD	R0, Y + 1		;get the bytes of the delay timer
00007c 8108      	LD	R16, Y			;get high byte first to avoid critical code
                 
00007d 2a00      	OR	R0, R16			;or bytes together to set R0 to T/F
00007e c001      	RJMP	EndDelayNotDone		;  (also sets ZF) and done
                 
                 
                 InvalidTimer:				;illegal timer number, return false
00007f 2400      	CLR	R0			;assumes FALSE is 0 and handles ZF too
                 	;RJMP	EndDelayNotDone		;and done
                 
                 
                 EndDelayNotDone:                        ;done figuring out if delay is done
000080 9508          RET
                 
                 
                 
                 
                 ; TimerHandler
                 ;
                 ; Description:       This is the handler for the timing system.  It is
                 ;                    expected that this function will be called every
                 ;                    millisecond.
                 ;
                 ; Operation:         Any non-zero delay times are decremented.
                 ;
                 ; Arguments:         None.
                 ; Return Value:      None.
                 ;
                 ; Local Variables:   None.
                 ; Shared Variables:  delay_timer - read and possibly written.
                 ; Global Variables:  None.
                 ;
                 ; Input:             None.
                 ; Output:            None.
                 ;
                 ; Error Handling:    None.
                 ;
                 ; Algorithms:        None.
                 ; Data Structures:   None.
                 ;
                 ; Registers Changed: flags, R18, R19, R20, R21, X (XH | XL)
                 ; Stack Depth:       0 bytes
                 ;
                 ; Author:            Glen George
                 ; Last Modified:     July 23, 2012
                 
                 TimerHandler:
                 
                 StartTmrHandler:			;update the delay timers if non-zero
000081 e8a0      	LDI		XL, LOW(delay_timer)	;get the timer address
000082 e0b1      	LDI		XH, HIGH(delay_timer)
000083 e025      	LDI		R18, TIMER_CNT		;number of timers to update
                 
                 TimerUpdateLoop:			;loop updating the timers
                 
000084 913d      	LD		R19, X+			;check if delay timer is done
000085 914d      	LD		R20, X+			;get both bytes
000086 2f53      	MOV		R21, R19		;and check for zero
000087 2b54      	OR		R21, R20
000088 f029      	BREQ	DoneTimer		;if so done with this timer
                 	;BRNE	DecTimer		;otherwise it needs to be decremented
                 
                 DecTimer:				;decrement the delay timer
000089 5031      	SUBI	R19, 1			;decrement low byte
00008a 4040      	SBCI	R20, 0			;propogating into high byte if needed
00008b 9712      	SBIW	X, 2			;get pointer back to start of timer
00008c 933d      	ST		X+, R19			;and store new timer value
00008d 934d      	ST		X+, R20
                 	;RJMP	DoneTimer		;and done with this timer
                 
                 DoneTimer:				;done decrementing this timer
00008e 952a      	DEC		R18			;update the timer counter
00008f f7a1      	BRNE	TimerUpdateLoop		;if not done, do the next timer
                 	;BREQ	DoneTmrHandler		;otherwise done with the handler
                 
                 
                 DoneTmrHandler:				; done with handler, return
000090 9518      	reti					; and return
                 
                 
                 
                 
                 ;the data segment
                 
                 
                 .dseg
                 
                 
000180           delay_timer:    .byte	2 * TIMER_CNT	; array of delay timers (2 bytes/timer)
                 .include "chiptimer.asm"
                 
                 ; File:             timer.asm
                 ; Description:      This file contains the functions to setup the timers, and
                 ;                   the interrupt service routines for the timers.
                 ; Public Functions: TimerInit   - Initialize the timers
                 ;                   Timer0OverflowHandler - Timer0 overflow interrupt handler
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 2024/05/18 	- Initial Revision
                 ;					2024/06/01  - Added Timer1Init
                 ;-------------------------------------------------------------------------------
                 
                 .cseg
                 
                 
                 ; TimerInit
                 ;
                 ; Description:          This procedure initializes timer0 and timer1 for driving
                 ;                       the LEDs and speaker.
                 ; Operation:            This procedure calls Timer0Init and Timer1Init.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 InitChipTimers:
000091 d002      	rcall 	Timer0Init
000092 d009      	rcall 	Timer1Init
000093 9508      	ret
                 
                 
                 ; Timer0Init
                 ;
                 ; Description:          This procedure initializes timer0 for driving the LEDs
                 ;                       and button debouncing.
                 ; Operation:            This procedure will set the timer0 to overflow at 4 kHz,
                 ;                       and enable the timer0 overflow interrupt.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 Timer0Init:
000094 2700      	clr		r16
000095 bf02      	out		TCNT0, r16             	; clear timer 0 counter
000096 e002      	ldi		r16, TIMER_CLK_8		; use CLK/8 as timer source, gives
000097 bf03      	out		TCCR0, r16		        ; 8 MHz / 8 / 256, rate = 4 kHz
000098 b707      	in		r16, TIMSK		    	; get current timer interrupt masks
000099 6001      	ori		r16, 1 << TOV0			; turn on timer 0 interrupts
00009a bf07      	out		TIMSK, r16
00009b 9508      	ret
                 
                 
                 ; Timer1Init
                 ;
                 ; Description:          This procedure initializes timer1 for driving the speaker.
                 ; Operation:            This procedure will set the timer1 to operate in CTC,
                 ;                       toggle OC1A on compare match, and set prescaler to 64
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/31/2024
                 
                 Timer1Init:
00009c e400          ldi 	r16, (1 << COM1A0)					; toggle OC1A on compare match
00009d bd0f          out 	TCCR1A, r16
00009e e00b          ldi 	r16, (1 << WGM12) | TIMER_CLK_64	; CTC mode, CLK/64 gives 125 kHz
00009f bd0e          out 	TCCR1B, r16
0000a0 9508      	ret
                 
                 
                 ; DisplayTimerIRQ
                 ;
                 ; Description:          This procedure expects to be called by the Timer0
                 ;                       overflow interrupt. This procedure will call the display
                 ;                       multiplexer, which will update the display LEDs.
                 ; Operation:            Pushes the registers onto the stack, calls the display
                 ;                       multiplexer, and pops the registers off the stack.
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    None.
                 ;
                 ; Stack Depth:          16 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/18/2024
                 
                 Timer0OverflowHandler:
0000a1 930f      	push	r16
0000a2 931f      	push	r17
0000a3 932f      	push	r18
0000a4 933f      	push	r19
0000a5 934f      	push	r20
0000a6 935f      	push	r21
0000a7 936f      	push	r22
0000a8 937f      	push	r23
0000a9 938f      	push	r24
0000aa 939f      	push	r25
0000ab 93af      	push	r26
0000ac 93bf      	push	r27
0000ad 93cf      	push	r28
0000ae 93df      	push	r29
0000af 93ef      	push	r30
0000b0 93ff      	push	r31
0000b1 d04b      	rcall	DisplayMux
0000b2 d4a1      	rcall   DebounceButtons
0000b3 dfcd      	rcall   TimerHandler
0000b4 91ff      	pop		r31
0000b5 91ef      	pop		r30
0000b6 91df      	pop		r29
0000b7 91cf      	pop		r28
0000b8 91bf      	pop		r27
0000b9 91af      	pop		r26
0000ba 919f      	pop		r25
0000bb 918f      	pop		r24
0000bc 917f      	pop		r23
0000bd 916f      	pop		r22
0000be 915f      	pop		r21
0000bf 914f      	pop		r20
0000c0 913f      	pop		r19
0000c1 912f      	pop		r18
0000c2 911f      	pop		r17
0000c3 910f      	pop		r16
0000c4 9518      	reti
                 .include "display.asm"
                 
                 ; File:             display.asm
                 ; Description:      this file contains the display routines for the 7-segment and
                 ;                   the game LED display.
                 ; Public Functions: DisplayInit - initializes the display
                 ;                   ClearDisplay - clears the display
                 ;                   DisplayMux - writes the values in the buffers to the display
                 ;                   DisplayHex - displays a hexadecimal number to the 7-segment LED
                 ;                   DisplayGameLED - controls the status of an individual LED
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 5/18/2024 - Initial revision
                 ;                   5/18/2024 - Debug and test
                 ;                   2024/06/12 - Update DisplayGameLED to not handle mode and
                 ;                                start buttons, and created specialized routines
                 ;                                for them.
                 
                 
                 ;-------------------------------------------------------------------------------
                 .cseg
                 
                 
                 MessageTable:
0000c5 00ff          .db TIMED,          0x00
                     .equ PADDING_SIZE = 2 * (PC - MessageTable)
0000c6 2020
0000c7 7420          .db "   t"
                     .equ MESSAGE_ENTRY_SIZE = 2 * (PC - MessageTable)
                     .equ MSG_LENGTH = MESSAGE_ENTRY_SIZE - PADDING_SIZE
0000c8 00fe
0000c9 7645
0000ca 7245          .db INFINITE,       0x00,   "EvEr"
0000cb 0000
0000cc 7247
0000cd 7541          .db GRAVITY,        0x00,   "GrAu"
0000ce 00a9
0000cf 6e49
0000d0 6975          .db f_invis_set,        0x00,   "Inui"
0000d1 0002
0000d2 4445
0000d3 4547          .db BOUND,          0x00,   "EDGE"
0000d4 0003
0000d5 4172
0000d6 646e          .db RANDOM_V,       0x00,   "rAnd"
0000d7 0004
0000d8 4720
0000d9 3d74          .db TIME_LIM,  0x00,   " Gt="
0000da 0005
0000db 4142
0000dc 4c4c          .db SIZE,      0x00,   "BALL"
0000dd 001f
0000de 4f4c
0000df 4553          .db LOSE,           0x00,   "LOSE"
0000e0 000f
0000e1 5d3d
0000e2 2020          .db WIN,            0x00,   "=]  "
                     .equ MESSAGE_ENTRIES = (PC - MessageTable) / (MESSAGE_ENTRY_SIZE / 2)
0000e3 0000
0000e4 4520
0000e5 7272          .db 0x00,           0x00,   " Err"
                 
                 ;-------------------------------------------------------------------------------
                 
                 .dseg
                 
00018a           curr_c_patterns:        .byte       DISP_BUFF_LEN
000198           curr_dig:               .byte       1
000199           curr_dig_pattern:       .byte       1
00019a           curr_msg:               .byte       MSG_LENGTH
00019e           blink_dim_cnt:          .byte       1
00019f           display_on_t:           .byte       1
0001a0           display_off_t:          .byte       1
                 
                 ; DisplayInit
                 ; Description:          This procedure initializes the variables for the 
                 ;                       display. It clears all the digits and the game LEDs.
                 ;                       Also initializes the parallel IO register for
                 ;					    the display multiplexer.
                 ; Operation:            This procedure clears the current digit and the blink/dim
                 ;                       counter. It then sets the current digit pattern to LED_OFF
                 ;                       and calls ClearDisplay to clear the display.
                 ;                       It will also set port A,C,D to be all ouotputs.
                 ; 
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     curr_c_patterns   - a table of port C patterns
                 ;                       curr_dig             - current digit to display
                 ;                       curr_dig_pattern      - current digit pattern to display
                 ;                       blink_dim_cnt         - for blinking/dimming the display
                 ; Local Variables:      LED_OFF holder (r16)
                 ;                       zero holder (r1)
                 ; 
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r1, r16
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/18/2024
                 .cseg
                 InitDisplay:
0000e6 2411          clr     r1
0000e7 9210 0198     sts     curr_dig, r1
0000e9 9210 019e     sts     blink_dim_cnt, r1
0000eb e000          ldi     r16, LED_OFF
0000ec 9300 0199     sts     curr_dig_pattern, r16
0000ee d001          rcall   ClearDisplay
0000ef 9508          ret
                 
                 
                 ; ClearDisplay
                 ; Description:          This procedure clears the display.
                 ; Operation:            This procedure will set all the currDigPatterns to the 
                 ;                       blank digit pattern.
                 ; 
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     curr_c_patterns     - a table of current digit patterns
                 ; Local Variables:      loop counter (r16)
                 ;                       LED_OFF holder (r17)
                 ; 
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ; Registers Used:       r16, r17, Y
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/18/2024
                 
                 ClearDisplay:
                 
0000f0 e00e          ldi     r16, DISP_BUFF_LEN
0000f1 920f
0000f2 e8ca
0000f3 e0d1
0000f4 0fc0
0000f5 2400
0000f6 1dd0
0000f7 900f          byteTabOffsetY  curr_c_patterns, r16
0000f8 e010          ldi     r17, LED_OFF
                 
                 ClearDisplayLoop:
0000f9 931a          st      -Y, r17
0000fa 950a          dec     r16
0000fb f7e9          brne    ClearDisplayLoop
                     ; breq  ClearDisplayEnd
                 
                 ClearDisplayEnd:
0000fc 9508          ret
                 
                 
                 
                 ; DisplayMux
                 ; Description:          This procedure writes the values in the buffers to the
                 ;                       display and game LEDs. It expects to be called by the
                 ;                       timer interrupt at a regular interval.
                 ; Operation:            This procedure will write a output pattern to the GPIO,
                 ;                       corresponding to a digit or game LED block. It will then
                 ;                       increment/wrap the current digit and the blink/dim
                 ;                       counter.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     curr_c_patterns   - a table of port C patterns
                 ;                       curr_dig             - current digit to display
                 ;                       curr_dig_pattern      - current digit pattern to display
                 ;                       blink_dim_cnt         - for blinking/dimming the display
                 ; Local Variables:      LED_OFF (r16)       - turns off a port
                 ;                       blink_dim_cnt (r16)   - counter for blinking/dimming
                 ;                       curr_dig (r17)       - current digit to display
                 ;                       portPattern (r18)   - current port pattern
                 ; 
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17, r18, Y, Z
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/18/2024
                 
                 DisplayMux:
                 
0000fd e000          ldi     r16, LED_OFF
0000fe bb0b          out     PORTA, r16
0000ff bb02          out     PORTD, r16
                 
000100 9100 019e     lds     r16, blink_dim_cnt
000102 9110 019f     lds     r17, display_on_t
000104 1701          cp      r16, r17
000105 f520          brsh    IncDimCnt
000106 f000          brlo    DisplayDigit
                 
                 DisplayDigit:
000107 9110 0198     lds     r17, curr_dig
                 
000109 920f
00010a e8ca
00010b e0d1
00010c 0fc1
00010d 2400
00010e 1dd0
00010f 900f          byteTabOffsetY  curr_c_patterns, r17
000110 8128          ld      r18, Y
000111 bb25          out     PORTC, r18
                 
000112 920f
000113 eae6
000114 e0f9
000115 0fe1
000116 2400
000117 1df0
000118 900f          wordTabOffsetZ  PortAPatterns, r17
000119 9124          lpm     r18, Z
00011a bb2b          out     PORTA, r18
                 
00011b 920f
00011c ebe4
00011d e0f9
00011e 0fe1
00011f 2400
000120 1df0
000121 900f          wordTabOffsetZ  PortDPatterns, r17
000122 9124          lpm     r18, Z
000123 bb22          out     PORTD, r18
                     ; rjmp  IncCurrDig
                 
                 IncCurrDig:
000124 9513          inc     r17
000125 301e          cpi     r17, DISP_BUFF_LEN
000126 f409          brne    StoreCurrDig
                     ; breq  WrapBuffer
                 
                 WrapBuffer:
000127 2711          clr r17
                     ; rjmp  StoreCurrDig
                 
                 StoreCurrDig:
000128 9310 0198     sts     curr_dig, r17
                 	; rjmp  IncDimCnt
                 
                 IncDimCnt:
00012a 9503          inc     r16
00012b 9110 019f     lds     r17, display_on_t
00012d 9120 01a0     lds     r18, display_off_t
00012f 0f12          add     r17, r18
000130 1701          cp      r16, r17
000131 f409          brne    StoreDimCnt
                 
                 WrapDimCnt:
000132 2700          clr     r16
                     ; rjmp  storeDimCnt
                 
                 StoreDimCnt:
000133 9300 019e     sts     blink_dim_cnt, r16
                     ; rjmp  DisplayMuxEnd
                 
                 DisplayMuxEnd:
000135 9508          ret
                 
                 
                 
                 ; DisplayHex
                 ; Description:          This procedure displays a hexadecimal number (n) to the 
                 ;                       7-segment LED display.
                 ; Operation:            The procedure will set the currentDigitPatterns to the 
                 ;                       corresponding digit pattern for each digit of the number.
                 ; 
                 ; Arguments:            n is passed in r17|r16 by value; it is preserved.
                 ; Return Value:         None.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     curr_c_patterns   - a table of port C patterns
                 ; Local Variables:      n (r17|r16)
                 ;                       temp digit holder (r18)
                 ;                       loop counter (r19)
                 ;                       temp pattern holder (r20)
                 ; 
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       If fewer than 4 digits are provided, the proedure will
                 ;                       display display the number in the registers regardless,
                 ;                       which is not guaranteed a default value.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17, r18, r19, r20,Y, Z
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/18/2024
                 
                 DisplayHex:
000136 e03a          ldi     r19, SEG_BUF_OFFSET
000137 2f20          mov     r18, r16
000138 702f          andi    r18, LOW_HEX_DIG        ; low digit of r16
000139 d00f          rcall   LoadHexDigit
                 
00013a 9533          inc     r19
00013b 2f20          mov     r18, r16
00013c 9522          swap    r18
00013d 702f          andi    r18, LOW_HEX_DIG
00013e d00a          rcall   LoadHexDigit
                 
00013f 9533          inc     r19
000140 2f21          mov     r18, r17
000141 702f          andi    r18, LOW_HEX_DIG
000142 d006          rcall   LoadHexDigit
                 
000143 9533          inc     r19
000144 2f21          mov     r18, r17
000145 9522          swap    r18
000146 702f          andi    r18, LOW_HEX_DIG       ; high digit of r17
000147 d001          rcall   LoadHexDigit
000148 9508          ret
                 
                 LoadHexDigit:
000149 920f
00014a e9e6
00014b e0f9
00014c 0fe2
00014d 2400
00014e 1df0
00014f 900f          wordTabOffsetZ  DigitSegTable, r18
000150 9144          lpm     r20, Z
000151 920f
000152 e8ca
000153 e0d1
000154 0fc3
000155 2400
000156 1dd0
000157 900f          byteTabOffsetY  curr_c_patterns, r19
000158 8348          st      Y, r20
000159 9508          ret
                 
                 
                 ;-------------------------------------------------------------------------------
                 ; r16 hols the message number to display
                 DisplayMessage:
00015a ece5          ldi     ZL, low(MessageTable)
00015b e0f0          ldi     ZH, high(MessageTable)
00015c e01a          ldi     r17, MESSAGE_ENTRIES
                 
                 DisplayMessageLookupLoop:
00015d 9125          lpm     r18, Z+
00015e 1720          cp      r18, r16
00015f f019          breq    DisplayMessageLookupMatch
                     ; brne DisplayMessageLookupNoMatch
                 
                 DisplayMessageLookupNoMatch:
000160 9635          adiw    Z, MESSAGE_ENTRY_SIZE-1
000161 951a          dec     r17
000162 f7d1          brne    DisplayMessageLookupLoop
                     ; rjmp DisplayMessageLookupMatch
                 
                 DisplayMessageLookupMatch:
000163 9631          adiw    Z, PADDING_SIZE-1
000164 2700          clr     r16
000165 920f
000166 e9ca
000167 e0d1
000168 0fc0
000169 2400
00016a 1dd0
00016b 900f          byteTabOffsetY  curr_msg, r16
00016c e014          ldi     r17, MSG_LENGTH
                 
                 DisplayMessageLoadMsgBufferLoop:
00016d 9105          lpm     r16, Z+
00016e 8308          st      Y, r16
00016f 951a          dec     r17
000170 f7e1          brne    DisplayMessageLoadMsgBufferLoop
                     ; breq DisplayMessageLoadDisplayBufferInit
                 
                 DisplayMessageLoadDisplayBufferInit:
000171 e00a          ldi     r16, SEG_BUF_OFFSET
000172 e014          ldi     r17, MSG_LENGTH
000173 920f
000174 e8ca
000175 e0d1
000176 0fc0
000177 2400
000178 1dd0
000179 900f          byteTabOffsetY curr_c_patterns, r16
00017a 2400          clr     r0
00017b 920f
00017c e1e6
00017d e0f9
00017e 0de0
00017f 2400
000180 1df0
000181 900f          wordTabOffsetZ ASCIISegTable, r0
                 
                 DisplayMessageLoadDisplayBufferLoop:
000182 9105          lpm     r16, Z+
000183 9309          st      Y+, r16
000184 951a          dec     r17
000185 f7e1          brne    DisplayMessageLoadDisplayBufferLoop
                     ; breq DisplayMessageEnd
                 
                 DisplayMessageEnd:
000186 9508          ret
                 
                 
                 
                 ; DisplayGameLED
                 ; 
                 ; Description:          This procedure controls the status of an individual LED in
                 ;                       the game board LEDs.
                 ; Operation:            This procedure will set one bit in curr_c_patterns to
                 ;                       either 1 or 0. If the provided LED number is out of range,
                 ;                       the procedure will return without doing anything.
                 ; 
                 ; Arguments:            r16 - An 8-bit LED number (l, 1-70) that indicates the
                 ;                             game board LED to turn on or off.
                 ;                       r17 - A boolean value that indicates the state of the game
                 ;                             board LED. If the value is TRUE (non-zero), the LED
                 ;                             will be turned on. If the value is FALSE (zero), it
                 ;                             will be turned off.
                 ; Return Value:         None.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     curr_c_patterns   - a table of port C patterns
                 ; Local Variables:      None.
                 ; 
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17, r18, r19, r20, Y
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/18/2024
                 
                 DisplayGameLED:
000187 950a          dec     r16
000188 3409          cpi     r16, LED_IDX_MAX+1
000189 f4e8          brsh    DisplayGameLEDEnd
00018a 3000          cpi     r16, LED_IDX_MIN
00018b f0d8          brlo    DisplayGameLEDEnd
00018c 2f20          mov     r18, r16
00018d 7027          andi    r18, MOD_8
                 
                 CreateLEDMaskInit:
00018e e830          ldi     r19, 0b10000000
                 
                 CreateLEDMaskLoop:
00018f 3020          cpi     r18, 0
000190 f019          breq    CreatePatternIndex
000191 952a          dec     r18
000192 9536          lsr     r19
000193 cffb          rjmp    CreateLEDMaskLoop
                 
                 CreatePatternIndex: ; r16 / 8
000194 9506          lsr    r16
000195 9506          lsr    r16
000196 9506          lsr    r16
                     ; rjmp CheckSetStatus
                 
                 CheckSetStatus:
000197 920f
000198 e8ca
000199 e0d1
00019a 0fc0
00019b 2400
00019c 1dd0
00019d 900f          byteTabOffsetY  curr_c_patterns, r16
00019e 8148          ld      r20, Y      ; prepare to set or clear the bit
00019f 3010          cpi    r17, FALSE
0001a0 f019          breq   DisplayGameLEDClear
                     ; brne DisplayGameLEDSet
                 
                 DisplayGameLEDSet:
0001a1 2b43          or      r20, r19
0001a2 8348          st      Y, r20
0001a3 c003          rjmp    DisplayGameLEDEnd
                 
                 DisplayGameLEDClear:
0001a4 9530          com     r19
0001a5 2343          and     r20, r19
0001a6 8348          st      Y, r20
                     ; rjmp  DisplayGameLEDEnd
                 
                 DisplayGameLEDEnd:
                 .include "div.asm"
0001a7 9508      
                 ; File:         div.asm
                 ; Description:  This file contains a function for doing division of 16-bit
                 ;               unsigned values.
                 ; Public Functions: Div16    - divide 16-bit unsigned values
                 ;
                 ; Author:       Glen George
                 ; Revision History:     4/16/18  Glen George      initial revision
                 ;-------------------------------------------------------------------------------
                 
                 .cseg
                 
                 
                 ; div16
                 ;
                 ;
                 ; Description:  This function divides the 16-bit unsigned value passed in
                 ;               r17|r16 by the 16-bit unsigned value passed in r21|r20.
                 ;               The quotient is returned in r17|r16 and the remainder is
                 ;               returned in r3|r2.
                 ;
                 ; Operation:    The function divides r17|r16 by r21|r20 using a restoring
                 ;               division algorithm with a 16-bit temporary register r3|r2
                 ;               and shifting the quotient into r17|r16 as the dividend is
                 ;               shifted out.  Note that the carry flag is the inverted
                 ;               quotient bit (and this is what is shifted into the
                 ;               quotient) so at the end the entire quotient is inverted.
                 ;
                 ; Arguments:        r17|r16 - 16-bit unsigned dividend.
                 ;                   r21|r20 - 16-bit unsigned divisor.
                 ; Return Values:    r17|r16 - 16-bit quotient.
                 ;                   r3|r2   - 16-bit remainder.
                 ;
                 ; Local Variables:  bitcnt (r22) - number of bits left in division.
                 ; Shared Variables: None.
                 ; Global Variables: None.
                 ;
                 ; Input:            None.
                 ; Output:           None.
                 ;
                 ; Error Handling:   None.
                 ;
                 ; Registers Changed:    flags, r2, r3, r16, r17, r22
                 ; Stack Depth:          0 bytes
                 ;
                 ; Algorithms:       Restoring division.
                 ; Data Structures:  None.
                 ;
                 ; Known Bugs:       None.
                 ; Limitations:      None.
                 ;
                 ; Revision History:   4/15/18   Glen George      initial revision
                 
                 Div16:
0001a8 e160          ldi     r22, 16         ;number of bits to divide into
0001a9 2433          clr     r3              ;clear temporary register (remainder)
0001aa 2422          clr     r2
                 
                 Div16loop:                  ;loop doing the division
0001ab 1f00          rol     r16             ;rotate bit into temp (and quotient
0001ac 1f11          rol     r17             ;   into r17|r16)
0001ad 1c22          rol     r2
0001ae 1c33          rol     r3
0001af 1624          cp      r2, r20         ;check if can subtract divisor
0001b0 0635          cpc     r3, r21
0001b1 f010          brcs    Div16SkipSub    ;cannot subtract, don't do it
0001b2 1a24          sub     r2, r20         ;otherwise subtract the divisor
0001b3 0a35          sbc     r3, r21
                 Div16SkipSub:               ;C = 0 if subtracted, C = 1 if not
0001b4 956a          dec     r22             ;decrement loop counter
0001b5 f7a9          brne    Div16loop           ;if not done, keep looping
0001b6 1f00          rol     r16             ;otherwise shift last quotient bit in
0001b7 1f11          rol     r17
0001b8 9500          com     r16             ;and invert quotient (carry flag is
0001b9 9510          com     r17             ;   inverse of quotient bit)
                     ;rjmp   enddiv16        ;and done (remainder is in r3|r2)
                 
                 EndDiv16:                   ;all done, just return
0001ba 9508          ret
                 
                 
                 
                 ; Div16by8
                 ;
                 ;
                 ; Description:       This function divides the 16-bit unsigned value passed in
                 ;                    R17|R16 by the 8-bit unsigned value passed in r20.  The
                 ;                    quotient is returned in R17|R16 and the remainder is
                 ;                    returned in r2.
                 ;
                 ; Operation:         The function divides R17|R16 by r20 using a restoring
                 ;                    division algorithm with an 8-bit temporary register r2
                 ;                    and shifting the quotient into R17|R16 as the dividend is
                 ;                    shifted out.  Note that the carry flag is the inverted
                 ;                    quotient bit (and this is what is shifted into the
                 ;                    quotient) so at the end the entire quotient is inverted.
                 ;
                 ; Arguments:         R17|R16 - 16-bit unsigned dividend.
                 ;                    r20     - 8-bit unsigned divisor.
                 ; Return Values:     R17|R16 - 16-bit quotient.
                 ;                    r2      - 8-bit remainder.
                 ;
                 ; Local Variables:   bitcnt (r22) - number of bits left in division.
                 ; Shared Variables:  None.
                 ; Global Variables:  None.
                 ;
                 ; Input:             None.
                 ; Output:            None.
                 ;
                 ; Error Handling:    None.
                 ;
                 ; Registers Changed: flags, r2, R16, R17, r22
                 ; Stack Depth:       0 bytes
                 ;
                 ; Algorithms:        Restoring division.
                 ; Data Structures:   None.
                 ;
                 ; Known Bugs:        None.
                 ; Limitations:       None.
                 ;
                 ; Revision History:   4/15/18   Glen George      initial revision
                 
                 Div16by8:
0001bb e160          ldi     r22, 16                 ;number of bits to divide into
0001bc 2422          clr     r2                      ;clear temporary register (remainder)
                 
                 Div16by8Loop:                       ;loop doing the division
0001bd 1f00          rol     r16                     ;rotate bit into temp (and quotient
0001be 1f11          rol     r17                     ;   into R17|R16)
0001bf 1c22          rol     r2
0001c0 1624          cp      r2, r20                 ;check if can subtract divisor
0001c1 f008          brcs    Div16by8SkipSub         ;cannot subtract, don't do it
0001c2 1a24          sub     r2, r20                 ;otherwise subtract the divisor
                 
                 Div16by8SkipSub:                    ;C = 0 if subtracted, C = 1 if not
0001c3 956a          dec     r22                     ;decrement loop counter
0001c4 f7c1          brne    Div16by8Loop            ;if not done, keep looping
0001c5 1f00          rol     r16                     ;otherwise shift last quotient bit in
0001c6 1f11          rol     r17
0001c7 9500          com     r16                     ;and invert quotient (carry flag is
0001c8 9510          com     r17                     ;   inverse of quotient bit)
                     ;rjmp   EndDiv16by8             ;and done (remainder is in r2)
                 
                 EndDiv16by8:                        ;all done, just return
                 .include "game.asm"
0001c9 9508      
0001a1           ball_pos:       .byte 1
0001a2           ball_pos_frac:  .byte 1
0001a3           velocity:       .byte 1
0001a4           game_time:      .byte 1
0001a5           is_invisible:   .byte 1
0001a6           in_game:        .byte 1
                 
                 
                 .cseg
                 
                 ;-------------------------------------
                 ; Initialize game variables and start all timers
                 InitGame:
0001ca e203          ldi     r16, START_POS
0001cb 9300 01a1     sts     ball_pos, r16
0001cd ef0e          ldi     r16, INFINITE
0001ce 9300 01ae     sts     mode, r16
0001d0 e000          ldi     r16, 0
0001d1 9300 01a4     sts     game_time, r16
0001d3 9300 01a2     sts     ball_pos_frac, r16
0001d5 9300 01a3     sts     velocity, r16
0001d7 e001          ldi     r16, DISP_ON_T_INIT
0001d8 9300 019f     sts     display_on_t, r16
0001da e000          ldi     r16, DISP_OFF_T_INIT
0001db 9300 01a0     sts     display_off_t, r16
0001dd 9508          ret
                 
                 ;-------------------------------------
                 GameLoop:
0001de d357          rcall  StartPress
0001df f179          breq   LoseGame
                 
0001e0 e001          ldi     r16, STATUS_TIMER_IDX
0001e1 de91          rcall   DelayNotDone
0001e2 f409      	brne    GameCheckGameTimer
0001e3 d0aa          rcall   StatusTimerHandler
                 
                 GameCheckGameTimer:
0001e4 e000          ldi     r16, GAME_TIMER_IDX
0001e5 de8d          rcall   DelayNotDone
0001e6 f409      	brne    GameCheckRandomEventTimer
0001e7 d099          rcall   GameTimerHandler
                 
                 GameCheckRandomEventTimer:
0001e8 e002          ldi     r16, RANDOM_EVENT_TIMER_IDX
0001e9 de89          rcall   DelayNotDone
0001ea f409      	brne    GameCheckSoundTimer
0001eb d0d6          rcall   RandomEventTimerHandler
                 
                 GameCheckSoundTimer:
0001ec e003          ldi     r16, SOUND_TIMER_IDX
0001ed de85          rcall   DelayNotDone
0001ee f409      	brne    GameLoopEnd
0001ef d23d          rcall   SoundTimerHandler
                     
                 GameLoopEnd:
0001f0 d322          rcall  ClearButtons
0001f1 9508          ret
                 
                 ;-------------------------------------
                 StartGame:
0001f2 e001          ldi     r16, TRUE
0001f3 9300 01a6     sts     in_game, r16
0001f5 9300 01af     sts     repeat, r16
0001f7 b71f
0001f8 94f8
0001f9 e607
0001fa 9300 01b2
0001fc e004
0001fd 9300 01b3
0001ff bf1f          PlaySequence GameMusic   ; play game music on repeat
000200 e203          ldi     r16, START_POS      ; set ball position to start position
000201 9300 01a1     sts     ball_pos, r16
000203 2400          clr     r0
000204 9200 01a4     sts     game_time, r0       ; reset game time, possibly set to setting time later
000206 9110 01ac     lds     r17, time_set
000208 9100 01ae     lds     r16, mode           ; check if mode is infinite
00020a ef2e          ldi     r18, INFINITE
00020b 1302          cpse    r16, r18           ; if mode is not infinite
00020c 9310 01a4     sts     game_time, r17      ; set game time to timed mode time
00020e 9508          ret
                 
                 ;-------------------------------------
                 
                 LoseGame:
00020f e000          ldi     r16, FALSE
000210 9300 01a6     sts     in_game, r16
000212 9300 01af     sts     repeat, r16
000214 b71f
000215 94f8
000216 e603
000217 9300 01b2
000219 e004
00021a 9300 01b3
00021c bf1f          PlaySequence LoseMusic
00021d e10f          ldi     r16, LOSE
00021e df3b          rcall   DisplayMessage
                     ; rcall DISPLAY?
                 
                 PlaySequenceLoop:
00021f e70f          ldi     r16, BLINK_TIME
000220 9300 019f     sts     display_on_t, r16
000222 9300 01a0     sts     display_off_t, r16
000224 9100 01b4     lds     r16, playing_sequence
000226 3001          cpi     r16, TRUE
000227 f3b9          breq PlaySequenceLoop
                     ; brne LoseGameEnd
                 
                 LoseGameEnd:
000228 dec7          rcall   ClearDisplay
000229 ef0f          ldi     r16, MAX_BRIGHTNESS
00022a 9300 019f     sts     display_on_t, r16
00022c 2400          clr     r0
00022d 9200 01a0     sts     display_off_t, r0
00022f e000          ldi     r16, FALSE
000230 9300 01a6     sts     in_game, r16
000232 9508          ret
                 
                 ;-------------------------------------
                 
                 WinGame:
000233 e000          ldi     r16, FALSE
000234 9300 01a6     sts     in_game, r16
000236 9300 01af     sts     repeat, r16
000238 b71f
000239 94f8
00023a e50d
00023b 9300 01b2
00023d e004
00023e 9300 01b3
000240 bf1f          PlaySequence WinMusic
000241 e00f          ldi     r16, WIN
000242 df17          rcall   DisplayMessage
                 
                 WaitSequenceLoop:
000243 9100 01b4     lds     r16, playing_sequence
000245 3001          cpi     r16, TRUE
000246 f3e1          breq    WaitSequenceLoop
                     ; brne WinGameEnd
                 
                 WinGameEnd:
000247 dea8          rcall   ClearDisplay
000248 9508          ret
                 
                 
                 ComputeUpperBound:
000249 9100 0023 	lds     r16, MIDDLE_LED
00024b 9110 01aa     lds     r17, bound_set
00024d 0f01          add     r16, r17
00024e 9508          ret
                 
                 
                 ComputeLowerBound:
00024f 9100 0023     lds     r16, MIDDLE_LED
000251 9110 01aa     lds     r17, bound_set
000253 1b01          sub     r16, r17
                 .include "gamedisplay.asm"
000254 9508      
                 
                 DisplayGameState:
000255 de9a          rcall   ClearDisplay
000256 d00c          rcall   DisplayBound
000257 d006          rcall   DisplayTime
000258 9100 01a5     lds     r16, is_invisible
00025a 3001      	cpi     r16, TRUE
00025b f009      	breq    DisplayGameStateEnd
00025c d00d          rcall   DisplayBall
                 
                 DisplayGameStateEnd:
00025d 9508          ret
                 
                 
                 ;-------------------------------------
                 DisplayTime:
00025e 9100 01a4     lds     r16, game_time
000260 2711          clr     r17
000261 ded4          rcall   DisplayHex
000262 9508          ret
                 
                 ;-------------------------------------
                 DisplayBound:
000263 dfe5          rcall   ComputeUpperBound
000264 e011          ldi     r17, TRUE
000265 df21          rcall   DisplayGameLED
000266 dfe8          rcall   ComputeLowerBound
000267 e011          ldi     r17, TRUE
000268 df1e          rcall   DisplayGameLED
000269 9508          ret
                 ;-------------------------------------
                 
                 DisplayBall:
00026a 9100 01a1     lds     r16, ball_pos
00026c 9120 0005     lds     r18, SIZE
00026e 952a          dec     r18         ; the radius of the ball (0 -> 1 LED, 1 -> 3 LEDs, etc.)
00026f 2f32          mov     r19, r18
000270 0f30          add     r19, r16    ; upper bound
000271 3436          cpi     r19, GAME_LED_IDX_MAX
000272 f008          brlo    DisplayBallLoopInit
                     ; brsh DisplayBallCapUpperBound
                 
                 DisplayBallCapUpperBound:
000273 e436          ldi     r19, GAME_LED_IDX_MAX
                     ; rjmp DisplayBallLoopInit
                 
                 DisplayBallLoopInit:
000274 1b02          sub     r16, r18    ; lower bound
000275 950a          dec     r16         ; subtract 1 because we increment first in the loop
000276 e011          ldi     r17, TRUE
                 
                 DisplayBallLoop:
000277 9503          inc     r16
000278 df0e          rcall   DisplayGameLED
000279 1303          cpse    r16, r19
00027a cffc          rjmp    DisplayBallLoop
                     ; rjmp DisplayBallEnd
                 
                 DisplayBallEnd:
                 .include "gametimer.asm"
00027b 9508      
00027c d067          rcall   StartGameTimer
00027d d06b          rcall   StartStatusTimer
00027e d06f          rcall   StartRandomEventTimer
00027f d073          rcall   StartSoundTimer
000280 9508          ret
                 
                 ;-------------------------------------
                 
                 GameTimerHandler:
000281 9100 01a4     lds     r16, game_time
000283 9110 01ae     lds     r17, mode
000285 3f1f          cpi     r17, TIMED
000286 f011          breq UpdateGameTimeModeTimed
                     ; brne UpdateGameTimeModeInfinite
                 
                 UpdateGameTimeModeInfinite:
000287 9503          inc     r16
000288 c001          rjmp    UpdateGameTimeEnd
                 
                 UpdateGameTimeModeTimed:
000289 950a          dec     r16
                     ; rjmp UpdateGameTimeEnd
                 
                 UpdateGameTimeEnd:
00028a 9300 01a4     sts     game_time, r16
00028c d057          rcall   StartGameTimer
00028d 9508          ret
                 
                 ;-------------------------------------
                 
                 StatusTimerHandler:
                 
00028e d072          rcall   GetAccelX
00028f 9512          swap    r17
000290 701f          andi    r17, LOW_HEX_DIG
000291 920f
000292 efe0
000293 e0f5
000294 0fe1
000295 2400
000296 1df0
000297 900f          wordTabOffsetZ IMU_TO_BALL_ACCEL, r17   ; half-byte accuracy is enough
000298 9104          lpm     r16, Z                          ; r16 = acceleration in ball units
000299 9110 0000     lds     r17, gravity
00029b 0201          muls    r16, r17
00029c 2d10          mov     r17, r0                         ; r17 = k_grav * acceleration
00029d 9100 01a3     lds     r16, velocity                   ; r16 = velocity (int value)
00029f 0f01          add     r16, r17                        ; r16 = new velocity
                     ; rjmp UpdateBallPos
                 
                 UpdateBallPos:
0002a0 9110 01a2     lds     r17, ball_pos_frac
0002a2 0f01          add     r16, r17
0002a3 2711          clr     r17
0002a4 e04a          ldi     r20, BALL_POS_FRAC_MAX
0002a5 df15          rcall   Div16by8
0002a6 9220 01a2     sts     ball_pos_frac, r2
0002a8 9110 01a1     lds     r17, ball_pos
0002aa 0f10          add     r17, r16
0002ab 9310 01a1     sts     ball_pos, r17
                     ; rjmp CheckWinLose
                 
                 CheckWinLose:
0002ad df9b          rcall   ComputeUpperBound
0002ae 9110 01a1     lds     r17, ball_pos
0002b0 1710          cp      r17, r16
0002b1 f450          brsh    CallLoseGame
0002b2 df9c          rcall   ComputeLowerBound
0002b3 9110 01a1     lds     r17, ball_pos
0002b5 1710          cp      r17, r16
0002b6 f028          brlo    CallLoseGame
0002b7 9100 01a4     lds     r16, game_time
0002b9 3000          cpi     r16, 0
0002ba f018          brlo    CallWinGame
0002bb c003          rjmp    StatusTimerHandlerEnd    ; neither win nor lose, continue game
                 
                 CallLoseGame:
0002bc df52          rcall   LoseGame
0002bd c001          rjmp    StatusTimerHandlerEnd
                 
                 CallWinGame:
0002be df74          rcall   WinGame
                     ; rjmp StatusTimerHandlerEnd
                 
                 StatusTimerHandlerEnd:
0002bf d029          rcall   StartStatusTimer
0002c0 df94          rcall   DisplayGameState
0002c1 9508          ret
                 
                 ;-------------------------------------
                 
                 RandomEventTimerHandler:
0002c2 d1b4          rcall   Random
                 
                 UpdateInvisible:
0002c3 9100 01b5     lds     r16, lfsr
0002c5 7007          andi    r16, 0x07
0002c6 9110 01a9 	lds     r17, f_invis_set
0002c8 1701          cp      r16, r17
0002c9 f000          brlo    SetInvisible
                     ; brge ClearInvisible
                 
                 SetInvisible:
0002ca e001          ldi     r16, TRUE
0002cb 9300 01a5     sts     is_invisible, r16
0002cd c003          rjmp    UpdateRandomV
                 
                 ClearInvisible:
0002ce e000          ldi     r16, FALSE
0002cf 9300 01a5     sts     is_invisible, r16
                     ; rjmp UpdateRandomV
                 
                 UpdateRandomV:
0002d1 d1a5          rcall   Random
0002d2 9100 01b5     lds     r16, lfsr
0002d4 2711          clr     r17
0002d5 9140 0003     lds     r20, random_v
0002d7 dee3          rcall   Div16by8
0002d8 9100 01a3     lds     r16, velocity
0002da 9110 01b6     lds     r17, lfsr+1
0002dc 2311          tst     r17
0002dd f009          breq AddRandomV
                     ; brne NegRandomV
                 
                 NegRandomV:
0002de 9421          neg     r2
                 
                 AddRandomV:
0002df 0d02          add     r16, r2
0002e0 9300 01a3     sts     velocity, r16
                     ; rjmp SpawnRandomEventEnd
                 
                 SpawnRandomEventEnd:
0002e2 d00b          rcall   StartRandomEventTimer
0002e3 9508          ret
                 
                 
                 
                 ;-------------------------------------
                 StartGameTimer:
0002e4 eea8          ldi     XL, low(GAME_TIMER_PERIOD)
0002e5 e0b3          ldi     XH, high(GAME_TIMER_PERIOD)
0002e6 e000          ldi     r16, GAME_TIMER_IDX
0002e7 dd80          rcall   StartDelay
0002e8 9508          ret
                 
                 ;-------------------------------------
                 
                 StartStatusTimer:
0002e9 e6a4          ldi     XL, low(STATUS_TIMER_PERIOD)
0002ea e0b0          ldi     XH, high(STATUS_TIMER_PERIOD)
0002eb e001          ldi     r16, STATUS_TIMER_IDX
0002ec dd7b          rcall   StartDelay
0002ed 9508          ret
                 
                 ;-------------------------------------
                 StartRandomEventTimer:
0002ee eea8          ldi     XL, low(RANDOM_EVENT_TIMER_PERIOD)
0002ef e0b3          ldi     XH, high(RANDOM_EVENT_TIMER_PERIOD)
0002f0 e002          ldi     r16, RANDOM_EVENT_TIMER_IDX
0002f1 dd76          rcall   StartDelay
0002f2 9508          ret
                 
                 ;-------------------------------------
                 StartSoundTimer:
0002f3 e6a4          ldi     XL, low(SOUND_TIMER_PERIOD)
0002f4 e0b0          ldi     XH, high(SOUND_TIMER_PERIOD)
0002f5 e003          ldi     r16, SOUND_TIMER_IDX
0002f6 dd71          rcall   StartDelay
0002f7 9508          ret
                 
                 IMU_TO_BALL_ACCEL:
                 .include "imu.asm"
0002f8 0000      
                 ; File:             imu.asm
                 ; Description:      This file contains the functions to interface with the IMU.
                 ; Public Functions: IMUInit     - initializes the IMU
                 ;                   GetAccelX   - gets the x-axis acceleration
                 ;                   GetAccelY   - gets the y-axis acceleration
                 ;                   GetAccelZ   - gets the z-axis acceleration
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 6/01/2024   - Initial Revision
                 ;-------------------------------------------------------------------------------
                 
                 
                 .cseg
                 
                 ; IMUInit
                 ; 
                 ; Description:          Initializes the config registers in the MPU6500.
                 ; Operation:            This function writes 0x00 to the general config and
                 ;                       accelerometer config registers of the MPU6500.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 InitIMU:
0002f9 e010          ldi     r17, IMU_CONFIG_RESET   ; the same reset value for all three
0002fa e10a          ldi     r16, IMU_GENERAL_CONFIG ; reset the general config register
0002fb d01e          rcall   IMUWrite
0002fc e10c          ldi     r16, IMU_ACCEL_CONFIG0  ; reset the accelerometer config register 0
0002fd d01c          rcall   IMUWrite
0002fe e10d          ldi     r16, IMU_ACCEL_CONFIG1  ; reset the accelerometer config register 1
0002ff d01a          rcall   IMUWrite
000300 9508          ret
                 
                 
                 ; GetAccelX
                 ; 
                 ; Description:          Reads the x-axis accelerometer value (16-bit signed).
                 ; Operation:            This function applies the GetAccel macro to the x-axis
                 ;                       accelerometer registers of the MPU6500. 
                 ; 
                 ; Arguments:            None.
                 ; Return Value:         r17|r16 - a 16-bit fixed-point value from -2 to 2 g 
                 ;                       representing the x-axis acceleration.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 GetAccelX:
000301 e30b
000302 d010
000303 2f10
000304 e30c
000305 d00d          GetAccel    IMU_AX_HIGH, IMU_AX_LOW
000306 9508          ret
                 
                 
                 ; GetAccelY
                 ; 
                 ; Description:          Reads the y-axis accelerometer value (16-bit signed).
                 ; Operation:            This function applies the GetAccel macro to the xy-axis
                 ;                       accelerometer registers of the MPU6500. 
                 ; 
                 ; Arguments:            None.
                 ; Return Value:         r17|r16 - a 16-bit fixed-point value from -2 to 2 g 
                 ;                       representing the y-axis acceleration.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 GetAccelY:
000307 e30d
000308 d00a
000309 2f10
00030a e30e
00030b d007          GetAccel    IMU_AY_HIGH, IMU_AY_LOW
00030c 9508          ret
                 
                 
                 ; GetAccelX
                 ; 
                 ; Description:          Reads the z-axis accelerometer value (16-bit signed).
                 ; Operation:            This function applies the GetAccel macro to the z-axis
                 ;                       accelerometer registers of the MPU6500. 
                 ; 
                 ; Arguments:            None.
                 ; Return Value:         r17|r16 - a 16-bit fixed-point value from -2 to 2 g 
                 ;                       representing the z-axis acceleration.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 GetAccelZ:
00030d e30f
00030e d004
00030f 2f10
000310 e400
000311 d001          GetAccel    IMU_AZ_HIGH, IMU_AZ_LOW
000312 9508          ret
                 
                 
                 
                 ; IMURead
                 ;
                 ; Description:          Reads a register from the IMU.
                 ; Operation:            This function reads a register from the IMU by pulling
                 ;                       the SS pin low, sending the register address with the
                 ;                       read bit set, and then reading the data from the IMU.
                 ;                       The second byte sent is ignored by the IMU. The SS pin
                 ;                       is then pulled high to end the transmission.
                 ;
                 ; Arguments:            r16 - the address of the register to read.
                 ; Return Value:         r16 - the data read from the register.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 IMURead:
000313 6800          ori     r16, IMU_READ                   ; set the read bit
000314 98c0          cbi     SPI_PORT, SPI_SS_PIN            ; SS low, start transmission
000315 d1e9          rcall   SPITxRx
000316 ef0f          ldi     r16, IMU_READ_IGNORE            ; send a dummy byte to read the data
000317 d1e7          rcall   SPITxRx
000318 9ac0          sbi     SPI_PORT, SPI_SS_PIN            ; SS high, end transmission
000319 9508          ret
                 
                 
                 ; IMURead
                 ;
                 ; Description:          Writes a register of the IMU.
                 ; Operation:            This function writes a register of the IMU by pulling
                 ;                       the SS pin low, sending the register address with the
                 ;                       read bit cleared, and then sending the byte to write to
                 ;                       the IMU. SS is then pulled high to end the transmission.
                 ;
                 ; Arguments:            r16 - the address of the register to write to.
                 ;                       r17 - the data to write to the register.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 IMUWrite:
00031a 770f          andi    r16, ~IMU_READ                  ; clear the read bit (write operation)
00031b 98c0          cbi     SPI_PORT, SPI_SS_PIN            ; SS low, start transmission
00031c d1e2          rcall   SPITxRx
00031d 2f01          mov     r16, r17                        ; send the data to write
00031e d1e0          rcall   SPITxRx
00031f 9ac0          sbi     SPI_PORT, SPI_SS_PIN            ; SS high, end transmission
000320 9508          ret
                 .include "io.asm"
                 
                 ; File:             io.asm
                 ; Description:  	This file contains the initialization routines for the I/Os
                 ;               	of the board.
                 ; Public Functions: IOInit      - initialize the DDRx registers for the display,
                 ;               	sound, and SPI I/Os
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 2024/06/01  - Initial revision
                 ;-------------------------------------------------------------------------------
                 
                 
                 .cseg
                 
                 ; IoInit
                 ;
                 ; Description:          This procedure initializes the IO ports for the display,
                 ;                       sound, and SPI.
                 ; Operation:            This procedure calls the DisplayIOInit, SoundIOInit, and
                 ;                       SPIIOInit procedures to initialize the DDRx registers for
                 ;                       the respective functions.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        2024/06/01
                 
                 InitIO:
000321 9478          sei
000322 d004          rcall   DisplayIOInit
000323 d008          rcall   SoundIOInit
000324 d00b          rcall   SPIIOInit
000325 d00f          rcall   SwitchIOInit
000326 9508          ret
                 
                 
                 ; DisplayIOInit
                 ;
                 ; Description:          This procedure initializes the I/O for the display.
                 ; Operation:            This procedure will set the sink and source ports of the
                 ;                       display to output.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/16/2024
                 
                 DisplayIOInit:
000327 ef0f          ldi	    r16,	OUTDATA
000328 bb0a          out     DISP_SRC_PORT0_DDR,   r16
000329 bb01          out	    DISP_SRC_PORT1_DDR,   r16
00032a bb04          out     DISP_SINK_PORT_DDR,   r16
00032b 9508          ret
                 
                 
                 ; SoundIOInit
                 ;
                 ; Description:          This procedure initializes the I/O for the sound.
                 ; Operation:            This procedure will set the speaker pin to be an output.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/16/2024
                 
                 SoundIOInit:
00032c b307          in      r16, SPEAKER_PORT_DDR
00032d 6200          ori     r16, (1 << SPEAKER_PIN)
00032e bb07          out     SPEAKER_PORT_DDR, r16
00032f 9508          ret
                 
                 
                 ; SPIIOInit
                 ;
                 ; Description:          This procedure initializes the I/O for SPI communication.
                 ; Operation:            This procedure will set the MOSI, SCK, and SS pins to be
                 ;                       outputs and the MISO pin to be an input in the SPI port.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/16/2024
                 
                 SPIIOInit:
000330 b307          in      r16, SPI_PORT_DDR
                     ; set MOSI, SCK, and SS as outputs
000331 6007          ori     r16, (1 << SPI_MOSI_PIN) | (1 << SPI_SCK_PIN) | (1 << SPI_SS_PIN)
000332 7f07          andi    r16, ~(1 << SPI_MISO_PIN)  ; set MISO as input
000333 bb07          out     SPI_PORT_DDR, r16
000334 9508          ret
                 
                 
                 SwitchIOInit:
000335 e000          ldi		r16,	INDATA
000336 b902          out		DDRE,	r16
                 .include "menu.asm"
000337 9508      
                 
0001a7           setting:			.byte 1
0001a8           gravity_set:        .byte 1
0001a9           f_invis_set:	    .byte 1
0001aa           bound_set:          .byte 1
0001ab           random_v_set:       .byte 1
0001ac           time_set:			.byte 1
0001ad           size_set:			.byte 1
0001ae           mode:				.byte 1
                 
                 .cseg
                 ;------------------------------------------------------------
                 MenuLoop:
000338 d1fd          rcall   StartPress
000339 f409          brne    MenuCheckModePress
00033a deb7      	rcall   StartGame
                 
                 MenuCheckModePress:
00033b d1f0          rcall   ModePress
00033c f409      	brne    MenuCheckRotPress
00033d d027      	rcall   ChangeMode
                 	
                 MenuCheckRotPress:
00033e d1e3          rcall   RotPress
00033f f409          brne    MenuCheckRotCCW
000340 d030      	rcall   ChangeSetting
                 
                 MenuCheckRotCCW:
000341 d1fe          rcall   RotCCW
000342 f409      	brne    MenuCheckRotCW
000343 d097          rcall   IncSetting
                 
                 MenuCheckRotCW:
000344 d205          rcall   RotCW
000345 f409      	brne    MenuCheckSoundTimer
000346 d041          rcall   DecSetting
                 
                 MenuCheckSoundTimer:
000347 e003          ldi     r16, SOUND_TIMER_IDX
000348 dd2a          rcall   DelayNotDone
000349 f409          brne    MenuLoopEnd
00034a d0e2          rcall   SoundTimerHandler
                 
                 MenuLoopEnd:
00034b 9508          ret
                 
                 
                 ;------------------------------------------------------------
                 InitSettings:
00034c e000          ldi     r16, GRAVITY
00034d 9300 01a7     sts     setting, r16
00034f e001          ldi     r16, GRAV_INIT
000350 9300 0000     sts     gravity, r16
000352 e000          ldi     r16, F_INVIS_INIT
000353 9300 01a9     sts     f_invis_set, r16
000355 e203          ldi     r16, BOUND_INIT
000356 9300 01aa     sts     bound_set, r16
000358 e000          ldi     r16, RANDOM_V_INIT
000359 9300 01ab     sts     random_v_set, r16
00035b e00a          ldi     r16, TIME_LIM_INIT
00035c 9300 01ac     sts     time_set, r16
00035e e001          ldi     r16, SIZE_INIT
00035f 9300 01ad     sts     size_set, r16
000361 ef0f          ldi     r16, TIMED
000362 9300 01ae     sts     mode, r16
000364 9508          ret
                 
                 
                 ;------------------------------------------------------------
                 ChangeMode:
000365 9100 01ae     lds     r16, mode
000367 3f0f          cpi     r16, TIMED
000368 f019          breq    SetModeInfinite
                     ; brne SetModeTimed
                 
                 SetModeTimed:
000369 ef0f          ldi     r16, TIMED
00036a ddef          rcall   DisplayMessage
00036b c002          rjmp    ChangeModeEnd
                 
                 SetModeInfinite:
00036c ef0e          ldi     r16, INFINITE
00036d ddec          rcall   DisplayMessage
                     ; rjmp ChangeModeEnd
                 
                 ChangeModeEnd:
00036e 9300 01ae     sts     mode, r16
000370 9508          ret
                 
                 
                 ;------------------------------------------------------------
                 ChangeSetting:
000371 e8e1          ldi     ZL, low(ChangeSettingTable)
000372 e0f3          ldi     ZH, high(ChangeSettingTable)
000373 e016          ldi     r17, N_SETTINGS
000374 9100 01a7     lds     r16, setting
                 
                 ChangeSettingLookupLoop:
000376 9125          lpm     r18, Z+
000377 1702          cp      r16, r18
000378 f019          breq    ChangeSettingLookupMatch
                     ; brne ChangeSettingLookupNoMatch
                 
                 ChangeSettingLookupNoMatch:
000379 9631          adiw    Z, CHANGE_SETTING_ENTRY_SIZE-1
00037a 951a          dec     r17
00037b f7d1          brne    ChangeSettingLookupLoop
                     ; breq ChangeSettingLookupMatch
                 
                 ChangeSettingLookupMatch:
00037c 9105          lpm     r16, Z+
00037d 9300 01a7     sts     setting, r16
00037f ddda          rcall   DisplayMessage
000380 9508          ret
                 
                 ChangeSettingTable:
000381 0100          .db     GRAVITY,        F_INVIS
                     .equ    CHANGE_SETTING_ENTRY_SIZE = 2 * (PC - ChangeSettingTable)
000382 0201          .db     F_INVIS,        BOUND
000383 0502          .db     BOUND,			SIZE
000384 0305          .db     SIZE,			RANDOM_V
000385 0403          .db     RANDOM_V,       TIME_LIM
000386 0004          .db     TIME_LIM,  GRAVITY
                     .equ    N_SETTINGS = (PC - ChangeSettingTable) /  (CHANGE_SETTING_ENTRY_SIZE / 2)
000387 0000          .db     0x00,           GRAVITY
                     
                 
                 ;------------------------------------------------------------
                 DecSetting:
000388 e9e7          ldi     ZL, low(DecSettingTable)
000389 e0f3          ldi     ZH, high(DecSettingTable)
00038a e016          ldi     r17, DEC_SETTING_ENTRIES
00038b 9100 01a7     lds     r16, setting
                 
                 DecSettingLookupLoop:
00038d 9125          lpm     r18, Z+
00038e 1702          cp      r16, r18
00038f f019          breq    DecSettingLookupMatch
                     ; brne DecSettingLookupNoMatch
                 
                 DecSettingLookupNoMatch:
000390 9633          adiw    Z, DEC_SETTING_ENTRY_SIZE-1
000391 951a          dec     r17
000392 f7d1          brne    DecSettingLookupLoop
                     ; breq DecSettingLookupMatch
                 
                 DecSettingLookupMatch:
000393 9125          lpm     r18, Z+
000394 9135          lpm     r19, Z+
000395 01f9          movw    Z, r18
000396 9409          ijmp
                 
                 
                 DecSettingTable:
000397 a500
000398 0003          .db     GRAVITY,        low(DecGravity),        high(DecGravity),       0x00
                     .equ    DEC_SETTING_ENTRY_SIZE = 2 * (PC - DecSettingTable)
000399 ae01
00039a 0003          .db     F_INVIS,          low(DecFInvis),  high(DecFInvis), 0x00
00039b b702
00039c 0003          .db     BOUND,          low(DecBound),          high(DecBound),         0x00
00039d d205
00039e 0003          .db     SIZE,      low(DecSize),       high(DecSize),      0x00
00039f c003
0003a0 0003          .db     RANDOM_V,       low(DecRandomV),        high(DecRandomV),       0x00
0003a1 c904
0003a2 0003          .db     TIME_LIM,  low(DecGameTime),       high(DecGameTime),      0x00
                     .equ    DEC_SETTING_ENTRIES = (PC - DecSettingTable) /  (DEC_SETTING_ENTRY_SIZE / 2)
0003a3 4c00
0003a4 0003          .db     0x00,           low(InitSettings),      high(InitSettings),     0x00
                 
                 
                 ; We follow the general scheme of decrementing the setting value only if it is
                 ; greater than the lower bound. If it is equal to the lower bound, we store the
                 ; lower bound value back to the setting and return
                 DecGravity:
0003a5 9100 0000     lds     r16, gravity
0003a7 e011      	ldi     r17, GRAV_LB
0003a8 1301      	cpse    r16, r17
0003a9 950a          dec     r16
0003aa 9300 0000     sts     gravity, r16
0003ac dd89          rcall   DisplayHex
0003ad 9508          ret
                 
                 DecFInvis:
0003ae 9100 01a9     lds     r16, f_invis_set
0003b0 e010      	ldi     r17, F_INVIS_LB
0003b1 1301      	cpse    r16, r17
0003b2 950a          dec     r16
0003b3 9300 01a9     sts     f_invis_set, r16
0003b5 dd80          rcall   DisplayHex
0003b6 9508          ret
                 
                 DecBound:
0003b7 9100 0002     lds     r16, bound
0003b9 e01a      	ldi     r17, BOUND_LB
0003ba 1301      	cpse    r16, r17
0003bb 950a          dec     r16
0003bc 9300 0002     sts     bound, r16
0003be dea4          rcall   DisplayBound
0003bf 9508          ret
                 
                 DecRandomV:
0003c0 9100 0003     lds     r16, random_v
0003c2 e010      	ldi     r17, RANDOM_V_LB
0003c3 1301      	cpse    r16, r17
0003c4 950a          dec     r16
0003c5 9300 0003     sts     random_v, r16
0003c7 dd6e          rcall   DisplayHex
0003c8 9508          ret
                 
                 DecGameTime:
0003c9 9100 01ac     lds     r16, time_set
0003cb e011      	ldi     r17, TIME_LIM_LB
0003cc 1301      	cpse    r16, r17
0003cd 950a          dec     r16
0003ce 9300 01ac     sts     time_set, r16
0003d0 dd65          rcall   DisplayHex
0003d1 9508          ret
                 
                 
                 DecSize:
0003d2 9100 01ad     lds     r16, size_set
0003d4 e011      	ldi     r17, SIZE_LB
0003d5 1301      	cpse    r16, r17
0003d6 950a          dec     r16
0003d7 9300 0005     sts     SIZE, r16
0003d9 de90          rcall   DisplayBall
0003da 9508          ret
                 
                 ;------------------------------------------------------------
                 IncSetting:
0003db eeea          ldi     ZL, low(IncSettingTable)
0003dc e0f3          ldi     ZH, high(IncSettingTable)
0003dd e016          ldi     r17, INC_SETTING_ENTRIES
0003de 9100 01a7     lds     r16, setting
                 
                 IncSettingLookupLoop:
0003e0 9125          lpm     r18, Z+
0003e1 1702          cp      r16, r18
0003e2 f019          breq    IncSettingLookupMatch
                     ; brne IncSettingLookupNoMatch
                 
                 IncSettingLookupNoMatch:
0003e3 9633          adiw    Z, DEC_SETTING_ENTRY_SIZE-1
0003e4 951a          dec     r17
0003e5 f7d1          brne    IncSettingLookupLoop
                     ; breq IncSettingLookupMatch
                 
                 IncSettingLookupMatch:
0003e6 9125          lpm     r18, Z+
0003e7 9135          lpm     r19, Z+
0003e8 01f9          movw    Z, r18
0003e9 9409          ijmp
                 
                 IncSettingTable:
0003ea f800
0003eb 0003          .db     GRAVITY,        low(IncGravity),        high(IncGravity),       0x00
                     .equ    INC_SETTING_ENTRY_SIZE = 2 * (PC - IncSettingTable)
0003ec 0101
0003ed 0004          .db     F_INVIS,        low(IncFInvis),         high(IncFInvis),        0x00
0003ee 0a02
0003ef 0004          .db     BOUND,          low(IncBound),          high(IncBound),         0x00
0003f0 2505
0003f1 0004          .db     SIZE,      low(IncSize),       high(IncSize),      0x00
0003f2 1303
0003f3 0004          .db     RANDOM_V,       low(IncRandomV),        high(IncRandomV),       0x00
0003f4 1c04
0003f5 0004          .db     TIME_LIM,  low(IncGameTime),       high(IncGameTime),      0x00
                     .equ    INC_SETTING_ENTRIES = (PC - IncSettingTable) /  (INC_SETTING_ENTRY_SIZE / 2)
0003f6 4c00
0003f7 0003          .db     0x00,           low(InitSettings),      high(InitSettings),     0x00
                 
                 ; We follow the general scheme of incrementing the setting value only if it is
                 ; lesser than the upper bound. If it is equal to the upper bound, we store the
                 ; upper bound value back to the setting and return
                 IncGravity:
0003f8 9100 0000     lds     r16, gravity
0003fa e014      	ldi     r17, GRAV_UB
0003fb 1301          cpse    r16, r17
0003fc 9503          inc     r16
0003fd 9300 0000     sts     gravity, r16
0003ff dd36          rcall   DisplayHex
000400 9508          ret
                 
                 IncFInvis:
000401 9100 01a9     lds     r16, f_invis_set
000403 e017      	ldi     r17, F_INVIS_UB
000404 1301          cpse    r16, r17
000405 9503          inc     r16
000406 9300 01a9     sts     f_invis_set, r16
000408 dd2d          rcall   DisplayHex
000409 9508          ret
                 
                 
                 IncBound:
00040a 9100 0002     lds     r16, bound
00040c e213      	ldi     r17, BOUND_UB
00040d 1301          cpse    r16, r17
00040e 9503          inc     r16
00040f 9300 0002     sts     bound, r16
000411 de51          rcall   DisplayBound
000412 9508          ret
                 
                 
                 IncRandomV:
000413 9100 0003     lds     r16, random_v
000415 e014      	ldi     r17, RANDOM_V_UB
000416 1301          cpse    r16, r17
000417 9503          inc     r16
000418 9300 0003     sts     random_v, r16
00041a dd1b          rcall   DisplayHex
00041b 9508          ret
                 
                 IncGameTime:
00041c 9100 01ac     lds     r16, time_set
00041e ef1f      	ldi     r17, TIME_LIM_UB
00041f 1301          cpse    r16, r17
000420 9503          inc     r16
000421 9300 01ac     sts     time_set, r16
000423 dd12          rcall   DisplayHex
000424 9508          ret
                 
                 
                 IncSize:
000425 9100 0005     lds     r16, SIZE
000427 e013      	ldi     r17, SIZE_UB
000428 1301          cpse    r16, r17
000429 9503          inc     r16
00042a 9300 0005     sts     SIZE, r16
                 .include "music.asm"
00042c 9508      
0001af           repeat:         .byte 1
0001b0           note_tick_cnt:  .byte 1
0001b1           curr_note:      .byte 1
0001b2           curr_sequence:	    .byte 2
0001b4           playing_sequence:   .byte 1
                 
                 
                 .cseg
                 
                 SoundTimerHandler:
00042d e001          ldi     r16, TRUE
00042e 9300 01b4     sts     playing_sequence, r16
000430 9100 01b0     lds     r16, note_tick_cnt
000432 950a          dec     r16
000433 f019          breq    NewNote
                 
                 ContinueNote:
000434 9300 01b0     sts     note_tick_cnt, r16
000436 c015          rjmp    SoundTimerHandlerEnd
                 
                 NewNote:
000437 9100 01b1     lds     r16, curr_note
000439 9503          inc     r16
00043a 9300 01b1     sts     curr_note, r16
00043c d011          rcall   GetNote
00043d 2300          tst     r16
00043e f461          brne    PlayNewNote
                     ; breq CheckRepeat
                 
                 CheckRepeat:
00043f 9100 01af     lds     r16, repeat
000441 3001          cpi     r16, TRUE
000442 f421          brne    RepeatSequence
000443 e000          ldi     r16, FALSE
000444 9300 01b4     sts     playing_sequence, r16
000446 c005          rjmp    SoundTimerHandlerEnd
                 
                 RepeatSequence:
000447 e000          ldi     r16, 0
000448 9300 01b1     sts     curr_note, r16
00044a d003          rcall   GetNote
                     ; rjmp PlayNewNote
                 
                 PlayNewNote:
00044b d099          rcall   PlayNote
                 
                 SoundTimerHandlerEnd:
00044c dea6          rcall   StartSoundTimer
00044d 9508          ret
                 ;-------------------------------------
                 
                 GetNote:
00044e 9100 01b1     lds     r16, curr_note
000450 0f00          lsl     r16
000451 2722          clr     r18
000452 91e0 01b2     lds     ZL, curr_sequence
000454 91f0 01b3     lds     ZH, curr_sequence+1
000456 0fe0          add     ZL, r16
000457 1ff2          adc     ZH, r18
000458 9105          lpm     r16, Z+
000459 9124          lpm     r18, Z
00045a 9320 01b0     sts     note_tick_cnt, r18
00045c 9508          ret
                 
                 ;-------------------------------------
                 
                 
                 ; shift by 2 to make everything fit in one byte
                 WinMusic:
00045d 0a41          .db     261 >> 2, 10    ; C
00045e 0a52          .db     330 >> 2, 10    ; E
00045f 0a52          .db     330 >> 2, 10    ; G
000460 0a41          .db     261 >> 2, 10    ; E
000461 0a62          .db     392 >> 2, 10    ; C
000462 0000          .db     0x00, 0         ; end
                 
                 LoseMusic:
000463 0a52          .db     330 >> 2, 10    ; E
000464 0a41          .db     261 >> 2, 10    ; C
000465 0a3d          .db     245 >> 2, 10    ; B
000466 0000          .db     0x00, 0         ; end
                 
                 GameMusic:
000467 0541          .db     261 >> 2, 5     ; C
000468 0545          .db     277 >> 2, 5     ; C#
000469 0549          .db     293 >> 2, 5     ; D
00046a 054d          .db     311 >> 2, 5     ; D#
00046b 0552          .db     330 >> 2, 5     ; E
00046c 054d          .db     311 >> 2, 5     ; D#
00046d 0549          .db     293 >> 2, 5     ; D
00046e 0545          .db     277 >> 2, 5     ; C#
00046f 0541          .db     261 >> 2, 5     ; C
                 .include "random.asm"
000470 0000      
0001b5           lfsr:  .byte 2
                 
                 ;-------------------------------------------------------------------------------
                 .cseg
                 
                 
                 InitRandom:
000471 ef0f          ldi     r16, low(LFSR_SEED)
000472 9300 01b5     sts     lfsr, r16
000474 e001          ldi     r16, high(LFSR_SEED)
000475 9300 01b6     sts     lfsr+1, r16
                 
                 Random:
000477 9100 01b5     lds     r16, lfsr
000479 9110 01b6     lds     r17, lfsr+1
00047b 2f20          mov     r18, r16
00047c 9522          swap    r18
00047d 7021          andi    r18, 0x01
00047e 2f31          mov     r19, r17
00047f 7031          andi    r19, 0x01
000480 2723          eor     r18, r19
000481 7021          andi    r18, 0x01  ; r18 is the feedback bit
000482 0f00          lsl     r16
000483 2b02          or      r16, r18
000484 1f11          rol     r17
000485 7011          andi    r17, 0x01
000486 9300 01b5     sts     lfsr, r16
000488 9310 01b6     sts     lfsr+1, r17
                 .include "segtable.asm"
00048a 9508      
                 ;                                                                            ;
                 ;                                   SEGTABLE                                 ;
                 ;                           Tables of 7-Segment Codes                        ;
                 ;                                                                            ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 ; This file contains tables of 7-segment codes.  The segment ordering is
                 ; given below.  The tables included are:
                 ;    ASCIISegTable - table of codes for 7-bit ASCII characters
                 ;    DigitSegTable - table of codes for hexadecimal digits
                 ;
                 ; Revision History:
                 ;     5/18/24  auto-generated           initial revision
                 ;     5/18/24  Glen George              added DigitSegTable
                 ;     5/18/24  Gavin Hua                added PortAPatterns and PortDPatterns
                 
                 
                 
                 ; local include files
                 ;    none
                 
                 
                 
                 
                 ;table is in the code segment
                         .cseg
                 
                 
                 
                 
                 ; ASCIISegTable
                 ;
                 ; Description:      This is the segment pattern table for ASCII characters.
                 ;                   It contains the active-high segment patterns for all
                 ;                   possible 7-bit ASCII codes.  Codes which do not have a
                 ;                   "reasonable" way of being displayed on a 7-segment display
                 ;                   are left blank.  None of the codes set the decimal point.
                 ;
                 ; Notes:            READ ONLY tables should always be in the code segment so
                 ;                   that in a standalone system it will be located in the
                 ;                   ROM with the code.
                 ;
                 ; Author:           auto-generated
                 ; Last Modified:    May 18, 2024
                 
                 ASCIISegTable:
                 
                 
                 ;        DB       gfeedcba    gfeedcba   ; ASCII character
                 
00048b 0000              .db     0b00000000, 0b00000000   ; NUL, SOH
00048c 0000              .db     0b00000000, 0b00000000   ; STX, ETX
00048d 0000              .db     0b00000000, 0b00000000   ; EOT, ENQ
00048e 0000              .db     0b00000000, 0b00000000   ; ACK, BEL
00048f 0000              .db     0b00000000, 0b00000000   ; backspace, TAB
000490 0000              .db     0b00000000, 0b00000000   ; new line, vertical tab
000491 0000              .db     0b00000000, 0b00000000   ; form feed, carriage return
000492 0000              .db     0b00000000, 0b00000000   ; SO, SI
000493 0000              .db     0b00000000, 0b00000000   ; DLE, DC1
000494 0000              .db     0b00000000, 0b00000000   ; DC2, DC3
000495 0000              .db     0b00000000, 0b00000000   ; DC4, NAK
000496 0000              .db     0b00000000, 0b00000000   ; SYN, ETB
000497 0000              .db     0b00000000, 0b00000000   ; CAN, EM
000498 0000              .db     0b00000000, 0b00000000   ; SUB, escape
000499 0000              .db     0b00000000, 0b00000000   ; FS, GS
00049a 0000              .db     0b00000000, 0b00000000   ; AS, US
                 
                 ;        DB       gfeedcba    gfeedcba   ; ASCII character
                 
00049b 0000              .db     0b00000000, 0b00000000   ; space, !
00049c 0042              .db     0b01000010, 0b00000000   ; ", #
00049d 0000              .db     0b00000000, 0b00000000   ; $, %
00049e 0200              .db     0b00000000, 0b00000010   ; &, '
00049f 0f79              .db     0b01111001, 0b00001111   ; (, )
0004a0 0000              .db     0b00000000, 0b00000000   ; *, +
0004a1 8000              .db     0b00000000, 0b10000000   ; ,, -
0004a2 0000              .db     0b00000000, 0b00000000   ; ., /
0004a3 067f              .db     0b01111111, 0b00000110   ; 0, 1
0004a4 8fbb              .db     0b10111011, 0b10001111   ; 2, 3
0004a5 cdc6              .db     0b11000110, 0b11001101   ; 4, 5
0004a6 07fd              .db     0b11111101, 0b00000111   ; 6, 7
0004a7 c7ff              .db     0b11111111, 0b11000111   ; 8, 9
0004a8 0000              .db     0b00000000, 0b00000000   ; :, ;
0004a9 8800              .db     0b00000000, 0b10001000   ; <, =
0004aa 0000              .db     0b00000000, 0b00000000   ; >, ?
                 
                 ;        DB       gfeedcba    gfeedcba   ; ASCII character
                 
0004ab f7bf              .db     0b10111111, 0b11110111   ; @, A
0004ac 79ff              .db     0b11111111, 0b01111001   ; B, C
0004ad f97f              .db     0b01111111, 0b11111001   ; D, E
0004ae fdf1              .db     0b11110001, 0b11111101   ; F, G
0004af 06f6              .db     0b11110110, 0b00000110   ; H, I
0004b0 003e              .db     0b00111110, 0b00000000   ; J, K
0004b1 0078              .db     0b01111000, 0b00000000   ; L, M
0004b2 7f00              .db     0b00000000, 0b01111111   ; N, O
0004b3 00f3              .db     0b11110011, 0b00000000   ; P, Q
0004b4 cd00              .db     0b00000000, 0b11001101   ; R, S
0004b5 7e00              .db     0b00000000, 0b01111110   ; T, U
0004b6 0000              .db     0b00000000, 0b00000000   ; V, W
0004b7 c600              .db     0b00000000, 0b11000110   ; X, Y
0004b8 7900              .db     0b00000000, 0b01111001   ; Z, [
0004b9 0f00              .db     0b00000000, 0b00001111   ; \, ]
0004ba 0800              .db     0b00000000, 0b00001000   ; ^, _
                 
                 ;        DB       gfeedcba    gfeedcba   ; ASCII character
                 
0004bb 0040              .db     0b01000000, 0b00000000   ; `, a
0004bc b8fc              .db     0b11111100, 0b10111000   ; b, c
0004bd 00be              .db     0b10111110, 0b00000000   ; d, e
0004be cf00              .db     0b00000000, 0b11001111   ; f, g
0004bf 04f4              .db     0b11110100, 0b00000100   ; h, i
0004c0 0000              .db     0b00000000, 0b00000000   ; j, k
0004c1 0070              .db     0b01110000, 0b00000000   ; l, m
0004c2 bcb4              .db     0b10110100, 0b10111100   ; n, o
0004c3 0000              .db     0b00000000, 0b00000000   ; p, q
0004c4 00b0              .db     0b10110000, 0b00000000   ; r, s
0004c5 3cf8              .db     0b11111000, 0b00111100   ; t, u
0004c6 0000              .db     0b00000000, 0b00000000   ; v, w
0004c7 ce00              .db     0b00000000, 0b11001110   ; x, y
0004c8 0000              .db     0b00000000, 0b00000000   ; z, {
0004c9 0006              .db     0b00000110, 0b00000000   ; |, }
0004ca 0001              .db     0b00000001, 0b00000000   ; ~, rubout
                 
                 
                 
                 
                 ; DigitSegTable
                 ;
                 ; Description:      This is the segment pattern table for hexadecimal digits.
                 ;                   It contains the active-high segment patterns for all hex
                 ;                   digits (0123456789AbCdEF).  None of the codes set the
                 ;                   decimal point.  
                 ;
                 ; Notes:            READ ONLY tables should always be in the code segment so
                 ;                   that in a standalone system it will be located in the
                 ;                   ROM with the code.
                 ;
                 ; Author:           Glen George
                 ; Last Modified:    May 18, 2024
                 
                 DigitSegTable:
                 
                 
                 ;       db    gfeedcba    gfeedcba   ; Hex Digit
                 
0004cb 067f      	.db 0b01111111, 0b00000110   ; 0, 1
0004cc 8fbb      	.db 0b10111011, 0b10001111   ; 2, 3
0004cd cdc6      	.db 0b11000110, 0b11001101   ; 4, 5
0004ce 07fd      	.db 0b11111101, 0b00000111   ; 6, 7
0004cf c7ff      	.db 0b11111111, 0b11000111   ; 8, 9
0004d0 fcf7      	.db 0b11110111, 0b11111100   ; A, b
0004d1 be79      	.db 0b01111001, 0b10111110   ; C, d
0004d2 f1f9      	.db 0b11111001, 0b11110001   ; E, F
                 
                 
                 
                 
                 ; PortAPatterns
                 ;
                 ; Description:      This is the segment pattern table for the Port A, for the 
                 ;                   7-segment display and the game LEDs.
                 ;
                 ; Notes:            READ ONLY tables should always be in the code segment so
                 ;                   that in a standalone system it will be located in the
                 ;                   ROM with the code.
                 ;
                 ; Author:           Gavin Hua
                 ; Last Modified:    5/18/2024
                 PortAPatterns:
0004d3 0201      	.db	0b00000001, 0b00000010
0004d4 0804      	.db	0b00000100, 0b00001000
0004d5 2010      	.db	0b00010000, 0b00100000
0004d6 0040      	.db	0b01000000, 0b00000000
0004d7 0000      	.db	0b00000000, 0b00000000
0004d8 0000      	.db	0b00000000, 0b00000000
0004d9 0000      	.db	0b00000000, 0b00000000
                 
                 
                 ; PortDPatterns
                 ;
                 ; Description:      This is the segment pattern table for the Port D, for the 
                 ;                   7-segment display and the game LEDs.
                 ;
                 ; Notes:            READ ONLY tables should always be in the code segment so
                 ;                   that in a standalone system it will be located in the
                 ;                   ROM with the code.
                 ;
                 ; Author:           Gavin Hua
                 ; Last Modified:    5/18/2024
                 PortDPatterns:
0004da 0000      	.db	0b00000000, 0b00000000
0004db 0000      	.db	0b00000000, 0b00000000
0004dc 0000      	.db	0b00000000, 0b00000000
0004dd 0200      	.db	0b00000000, 0b00000010
0004de 0401      	.db	0b00000001, 0b00000100
0004df 1008      	.db	0b00001000, 0b00010000
                 .include "sound.asm"
0004e0 4020      
                 ; File:             sound.asm
                 ; Description:      This file contains the functions to initialize the speaker
                 ;                   and play a frequency.
                 ; Public Functions: SoundInit   - Initialize the speaker
                 ;                   PlayNote    - Play a note
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 6/01/2024   - Initial Revision
                 ;-------------------------------------------------------------------------------
                 
                 
                 .cseg
                 
                 ; SoundInit
                 ; 
                 ; Description:          Turns off the speaker. I/O initialization is done in
                 ;                       the general I/O initialization function.
                 ; Operation:            This function calls PlayNote with frequency 0 Hz.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None
                 ;
                 ; Input:                None.
                 ; Output:               If the speaker is on, it is turned off.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        6/01/2024
                 
                 InitSound:
0004e1 2711          clr     r17
0004e2 2700          clr     r16
0004e3 d001          rcall   PlayNote
0004e4 9508          ret
                 
                 
                 ; PlayNote
                 ; 
                 ; Description:          The function plays the note with the passed frequency 
                 ;                       (f, in Hz) on the speaker. This tone is output until a new
                 ;                       tone is output via this function. f = 0 Hz
                 ;                       turns off the speaker output. The max value of f is 
                 ;                       65536 Hz, which is the maximum unsigned number that can
                 ;                       be stored in 2 bytes.
                 ; Operation:            The function computes the compare register value by
                 ;                       dividing the scaled clock frequency with double the
                 ;                       output frequency and writes it to the output compare
                 ;                       register if f is not 0 Hz. Otherwise, the speaker is 
                 ;                       turned off.
                 ; 
                 ; Arguments:            r17|r16 - the frequency to play, in Hz.
                 ; Return Value:         None.
                 ; 
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ; 
                 ; Input:                None.
                 ; Output:               The speaker plays the note with frequency f, if f>0 Hz.
                 ;   
                 ; Error Handling:       If f = 0Hz, then nothing is output.
                 ;   
                 ; Algorithms:           Restoring division.
                 ; Data Structures:      None.
                 ;
                 ; Registers Used:       r16, r17
                 ; Stack Depth:          0
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        2024/06/01
                 
                 PlayNote:
0004e5 3010          cpi     r17, high(FREQ_OFF)
0004e6 f421          brne    ComputeCompareValue    ; f > 0 Hz, compute compare value
0004e7 3000          cpi     r16, low(FREQ_OFF)
0004e8 f411          brne    ComputeCompareValue    ; f > 0 Hz, compute compare value
                     ; breq Mute                 ; f = 0 Hz, turn off speaker
                 
                 Mute:
0004e9 98bd          cbi     SPEAKER_PORT_DDR, SPEAKER_PIN            ; disable speaker
0004ea c008          rjmp    PlayNoteEnd
                 
                 ComputeCompareValue:
0004eb 01a8          movw    r20, r16                    ; Div16 expects the divisor in r21:r20
0004ec ef14          ldi     r17, HIGH(FREQ_DIV)         ; Div16 expects the dividend in r17|r16
0004ed e204          ldi     r16, LOW(FREQ_DIV)
0004ee dcb9          rcall   Div16
0004ef 98bd          cbi     SPEAKER_PORT_DDR, SPEAKER_PIN   ; disable speaker while loading
0004f0 bd1b          out     OCR1AH, r17
0004f1 bd0a          out     OCR1AL, r16
0004f2 9abd          sbi     SPEAKER_PORT_DDR, SPEAKER_PIN            ; enable speaker
                     ; rjmp PlayNoteEnd
                 
                 PlayNoteEnd:
                 .include "spi.asm"
0004f3 9508      
                 ; File:             spi.asm
                 ; Description:      This file contains the functions to set up and use the SPI.
                 ; Public Functions: SPIInit     - Initialize SPI
                 ;                   SPITxRx     - Transmit and receive data over SPI
                 ;
                 ; Author:           Gavin Hua
                 ; Revision History: 6/01/2024   - Initial Revision
                 ;-------------------------------------------------------------------------------
                 
                 
                 .cseg
                 
                 ; SPIInit
                 ;
                 ; Description:  Initializes the SPI control register to conform to the MPU6500's
                 ;               SPI communication requirements.
                 ; Operation:    Disables SPI interrupt, enables SPI, sets MSB first, master mode,
                 ;               SCK idle high, sample on rising edge, f_spi = f_osc/16.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        2024/06/01
                 
                 InitSPI:
0004f4 e70f          ldi     r16, ~(1 << SPIE)       ; disable SPI interrupt
0004f5 6400          ori     r16, (1 << SPE)         ; enable SPI
0004f6 7d0f          andi    r16, ~(1 << DORD)       ; MSB first
0004f7 6100          ori     r16, (1 << MSTR)        ; master mode
0004f8 6008          ori     r16, (1 << CPOL)        ; SCK idle high
0004f9 6004          ori     r16, (1 << CPHA)        ; sample on rising edge
0004fa 7f0d          andi    r16, ~(1 << SPR1)       ; f_spi = f_osc/16 (SPR[1:0] = 0b01)
0004fb 6001          ori     r16, (1 << SPR0)        ; since MPU6500 SPI max frequency is 1MHz
0004fc b90d          out     SPCR, r16
0004fd 9877          cbi     SPSR, SPIF
0004fe 9508          ret
                 
                 
                 ; SPITxRx
                 ;
                 ; Description:  Transmits and receives a byte of data over SPI.
                 ; Operation:    Loads data to be transmitted into SPDR, waits for transmission
                 ;               to complete, reads received data from SPDR.
                 ;
                 ; Arguments:    r16 - data to be transmitted.
                 ; Return Value: r16 - received data.
                 ;
                 ; Global Variables: None.
                 ; Shared Variables: None.
                 ; Local Variables: None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        2024/06/01
                 
                 SPITxRx:
0004ff b90f          out     SPDR, r16                   ; load data to be transmitted
                     ; rjmp TransmitWait
                 
                 TransmitWait:
000500 9b77          sbis    SPSR, SPIF
000501 cffe          rjmp    TransmitWait               ; wait for transmission to complete
                     ; rjmp TransmitFinish
                 
                 TransmitFinish:
000502 b10f          in      r16, SPDR                    ; read received data
000503 9508          ret
                 .include "switch.asm"
                 
                 ;                   Homework #2. The functions are used to debounce the input
                 ;                   switches and the rotary encoder. The functions are called
                 ;                   by the Event Handler to determine if the switches have been
                 ;                   pressed, and if the rotary encoder has been turned. The
                 ;                   functions are also used to determine the direction of
                 ;                   rotation of the rotary encoder.
                 ;
                 ; Input:            None.
                 ; Output:           None.
                 ;
                 ; User Interface:   None.
                 ; Error Handling:   None.
                 ;
                 ; Algorithms:       None.
                 ; Data Structures:  None.
                 ;
                 ; Known Bugs:       None.
                 ; Limitations:      None.
                 ;
                 ; Revision History:
                 ;       5/03/24     Gavin Hua      Initial Revision
                 ;       5/04/24     Gavin Hua      Debugged functions
                 
                 .dseg
                 
0001b7           start_pressed:  .byte   1
0001b8           start_cnt:      .byte   1
                 
0001b9           mode_pressed:   .byte   1
0001ba           mode_cnt:       .byte   1
                 
0001bb           rot_pressed:    .byte   1
0001bc           rot_cnt:        .byte   1
                 
0001bd           rot_state:      .byte   1
0001be           rot_cw:         .byte   1
0001bf           rot_ccw:        .byte   1
                 
                 
                 .cseg
                 
                 ; SwitchInit
                 ;
                 ; Description:          This procedure initializes the switch/encoder variables.
                 ; Operation:            This procedure will set the debounce counters to their
                 ;                       initial values, clear the rotary encoder history, and 
                 ;                       set the pressed flags to false.
                 ;
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     None.
                 ; Local Variables:      None.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;
                 ; Error Handling:       None.
                 ;
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    r16.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 SwitchInit:
000504 b60f          in      r0, SREG
000505 94f8          cli
000506 e00a          ldi     r16, DEBOUNCE_T
000507 9300 01b8     sts     start_cnt, r16
000509 9300 01ba     sts     mode_cnt,  r16
00050b 9300 01bc     sts     rot_cnt,   r16
00050d e000          ldi     r16, ENC_INIT_STATE
00050e 9300 01bd     sts     rot_state, r16
000510 d002          rcall   ClearButtons
000511 be0f          out     SREG, r0
000512 9508          ret
                 
                 
                 ClearButtons:
000513 b60f          in		r0, SREG
000514 94f8          cli
000515 e000          ldi     r16, FALSE
000516 9300 01b7     sts     start_pressed, r16
000518 9300 01b9     sts     mode_pressed, r16
00051a 9300 01bb     sts     rot_pressed, r16
00051c 9300 01be     sts     rot_cw, r16
00051e 9300 01bf     sts     rot_ccw, r16
000520 be0f          out     SREG, r0
000521 9508          ret
                 
                 
                 .macro CheckPressFlag
                     in      r0, SREG
                     cli
                     lds		r16, @0
                     ldi		r17, FALSE
                     sts		@0, r17
                     out		SREG, r0
                     cpi		r16, TRUE
                     ret
                 .endmacro
                 
                 
                 ; RotPress
                 ;
                 ; Description:          The procedure returns TRUE (zero flag set) if the rotary 
                 ;                       encoder switch has been pressed since the last time it 
                 ;                       was 
                 ;                       called. Otherwise FALSE (zero flag reset) is returned.
                 ; Operation:            This procedure will read the rot_pressed byte, which is set
                 ;                       by the Event Handler. If the rot_pressed byte is TRUE, then
                 ;                       the zero flag is set, otherwise it is reset. The rot_pressed
                 ;                       byte is then reset to FALSE.
                 ; Arguments:            None.
                 ; Return Value:         The Z flag, set if rotary encoder switch has been 
                 ;                       pressed, cleared otherwise.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     The rot_pressed byte is read and reset.
                 ; Local Variables:      r0  - register used to store the SREG.
                 ;                       r16 - register used to store the rot_pressed byte.
                 ;                       r17 - register used to reset the rot_pressed byte.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    SREG, r0, r16, r17.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 RotPress:
000522 b60f
000523 94f8
000524 9100 01bb
000526 e010
000527 9310 01bb
000529 be0f
00052a 3001
00052b 9508          CheckPressFlag  rot_pressed
                 
                 
                 ; ModePress
                 ;
                 ; Description:          The procedure returns TRUE (zero flag set) if the mode 
                 ;                       button has been pressed since the last time it was 
                 ;                       called. Otherwise FALSE (zero flag reset) is returned.
                 ; Operation:            This procedure will read the mode_pressed byte, which is 
                 ;                       set by the Event Handler. If the mode_pressed byte is 
                 ;                       TRUE, then the zero flag is set, otherwise it is reset.
                 ;                       The mode_pressed byte is then reset to FALSE.
                 ; Arguments:            None.
                 ; Return Value:         The Z flag, set if mode button has been pressed, cleared
                 ;                       otherwise.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     The mode_pressed byte is read and reset.
                 ; Local Variables:      r0  - register used to store the SREG.
                 ;                       r16 - register used to store the mode_pressed byte.
                 ;                       r17 - register used to reset the mode_pressed byte.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    SREG, r0, r16, r17.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 ModePress:
00052c b60f
00052d 94f8
00052e 9100 01b9
000530 e010
000531 9310 01b9
000533 be0f
000534 3001
000535 9508          CheckPressFlag  mode_pressed
                 
                 
                 ; StartPress
                 ;
                 ; Description:          The procedure returns TRUE (zero flag set) if the start 
                 ;                       button has been pressed since the last time it was 
                 ;                       called. Otherwise FALSE (zero flag reset) is returned.
                 ; Operation:            This procedure will read the start_pressed byte, which is 
                 ;                       set by the Event Handler. If the start_pressed byte is 
                 ;                       TRUE, then the zero flag is set, otherwise it is reset.
                 ;                       The start_pressed byte is then reset to FALSE.
                 ; Arguments:            None.
                 ; Return Value:         The Z flag, set if start button has been pressed, 
                 ;                       cleared otherwise.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     The start_pressed byte is read and reset.
                 ; Local Variables:      r0  - register used to store the SREG.
                 ;                       r16 - register used to store the start_pressed byte.
                 ;                       r17 - register used to reset the start_pressed byte.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    SREG, r0, r16, r17.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 StartPress:
000536 b60f
000537 94f8
000538 9100 01b7
00053a e010
00053b 9310 01b7
00053d be0f
00053e 3001
00053f 9508          CheckPressFlag  start_pressed
                 
                 
                 ; RotCCW
                 ;
                 ; Description:          The procedure returns TRUE (zero flag set) if the rotary 
                 ;                       encoder has been turned counterclockwise since the last 
                 ;                       time it was called. Otherwise FALSE (zero flag reset) is 
                 ;                       returned.
                 ; Operation:            This function will read the rot_ccw byte, which is 
                 ;                       set by the Event Handler. If the rot_ccw byte is 
                 ;                       TRUE, then the zero flag is set, otherwise it is reset. 
                 ;                       The rot_ccw byte is then reset to FALSE.
                 ; Arguments:            None.
                 ; Return Value:         The Z flag, set if rotary encoder has been turned 
                 ;                       counterclockwise, cleared otherwise.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     The rot_ccw byte is read and reset.
                 ; Local Variables:      r0  - register used to store the SREG.
                 ;                       r16 - register used to store the rot_ccw byte.
                 ;                       r17 - register used to reset the rot_ccw byte.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    SREG, r0, r16, r17.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 RotCCW:
000540 b60f
000541 94f8
000542 9100 01bf
000544 e010
000545 9310 01bf
000547 be0f
000548 3001
000549 9508          CheckPressFlag  rot_ccw
                 
                 
                 ; RotCW
                 ;
                 ; Description:          The procedure returns TRUE (zero flag set) if the rotary 
                 ;                       encoder has been turned clockwise since the last time it 
                 ;                       was called. Otherwise FALSE (zero flag reset) is returned.
                 ; Operation:            This function will read the rot_cw byte, which is 
                 ;                       set by the Event Handler. If the rot_cw byte is 
                 ;                       TRUE, then the zero flag is set, otherwise it is reset. 
                 ;                       The rot_cw byte is then reset to FALSE.
                 ; Arguments:            None.
                 ; Return Value:         The Z flag, set if rotary encoder has been turned 
                 ;                       clockwise, cleared otherwise.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     The rot_cw byte is read and reset.
                 ; Local Variables:      r0  - register used to store the SREG.
                 ;                       r16 - register used to store the rot_cw byte.
                 ;                       r17 - register used to reset the rot_cw byte.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      None.
                 ;
                 ; Registers changed:    SREG, r0, r16, r17.
                 ;
                 ; Stack Depth:          0 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 RotCW:
00054a b60f
00054b 94f8
00054c 9100 01be
00054e e010
00054f 9310 01be
000551 be0f
000552 3001
000553 9508          CheckPressFlag  rot_cw
                 
                 
                 ; DebounceTimerIRQ
                 ;
                 ; Description:          This procedure is called at a periodic interval to 
                 ;                       debounce the input switches and the rotary encoder.
                 ; Operation:            This procedure will debounce the switches and the rotary
                 ;                       encoders by waiting for the signals to settle for the 
                 ;                       former, and recording thesequences of events for the 
                 ;                       latter. We first dicuss the switches. If the switches
                 ;                       are pressed, the debounce counter is set to the debounce
                 ;                       time. If the debounce counter is not zero, it is
                 ;                       decremented. If the debounce counter is zero, the
                 ;                       corresponding pressed flag is set. The rotary encoder
                 ;                       is debounced by recording the sequence of events since
                 ;                       the last time the encoder was in the detent position.
                 ;                       The encoder reading is compared with the previous state
                 ;                       to determine if the encoder has moved. If the encoder
                 ;                       has moved, the state is updated. If the encoder is in
                 ;                       the detent position, the direction of rotation is
                 ;                       determined. If the encoder is turned clockwise, the
                 ;                       rot_cw flag is set. If the encoder is turned
                 ;                       counterclockwise, the rot_ccw flag is set.
                 ;                       The procedure ends by returning from the interrupt.
                 ; Arguments:            None.
                 ; Return Value:         None.
                 ;
                 ; Global Variables:     None.
                 ; Shared Variables:     The debounce counters, the pressed flags, and the state
                 ;                       of the rotary encoder are updated.
                 ; Local Variables:      r16 - register used to store the current state of the
                 ;                             switches and the rotary encoder.
                 ;                       r17 - register used to mask the switches.
                 ;                       r18 - register used to manipulate the debounce counter.
                 ;                       r19 - register used to set the pressed flags.
                 ;                       r20 - register used to store the encoder reading.
                 ;                       r21 - register used to store the past rotation states.
                 ;                       r22 - register used to store the two bits of interest in
                 ;                             the state recording.
                 ;
                 ; Input:                None.
                 ; Output:               None.
                 ;   
                 ; Error Handling:       None.
                 ;   
                 ; Algorithms:           None.
                 ; Data Structures:      A length 4 array of 2-bits, stored in rot_state.
                 ;
                 ; Registers changed:    None. (SREG, r16..r23 are restored)
                 ;
                 ; Stack Depth:          8 bytes.
                 ;
                 ; Author:               Gavin Hua
                 ; Last Modified:        5/4/2024
                 
                 DebounceButtons:
                 
                 CheckStart:
000554 9120 01b8     lds     r18, start_cnt
000556 e830          ldi     r19, START_BTN_MASK
000557 d044          rcall   CheckBtn
000558 9320 01b8     sts     start_cnt, r18
00055a 9120 01b7     lds     r18, start_pressed
00055c 2b23          or      r18, r19
00055d 9320 01b7     sts     start_pressed, r18
                     ; rjmp  CheckMode
                 
                 CheckMode:
00055f 9120 01ba     lds     r18, mode_cnt
000561 e430          ldi     r19, MODE_BTN_MASK
000562 d039          rcall   CheckBtn
000563 9320 01ba     sts     mode_cnt, r18
000565 9120 01b9     lds     r18, mode_pressed
000567 2b23          or      r18, r19
000568 9320 01b9     sts     mode_pressed, r18
                     ; rjmp  CheckRot
                 
                 CheckRot:
00056a 9120 01bc     lds     r18, rot_cnt
00056c e230          ldi     r19, ROT_BTN_MASK
00056d d02e          rcall   CheckBtn
00056e 9320 01bc     sts     rot_cnt, r18
000570 9120 01bb     lds     r18, rot_pressed
000572 2b23          or      r18, r19
000573 9320 01bb     sts     rot_pressed, r18
                     ; rjmp  CheckEnc
                 
                 CheckEnc:
000575 b141          in      r20, BUTTON_DATA
000576 7148          andi    r20, ENC_MASK    ; r20 stores the GPIO encoder reading
000577 0f44          lsl     r20                          ; align the reading with state[5:4]
000578 9150 01bd     lds     r21, rot_state    ; r21 stores the past rotation states
00057a 2f65          mov     r22, r21         ; r22 stores the two bits of interest
00057b 7360          andi    r22, ENC_BOUNCE_MASK
00057c 1764          cp      r22, r20
00057d f409          brne    EncNoBounce
                     ; BREQ  EncBounced
                 
                 EncBounced:
00057e c01c          rjmp    DebounceButtonsEnd
                 
                 EncNoBounce:
00057f 2f65          mov     r22, r21
000580 7c60          andi    r22, ENC_PREV_MASK
000581 0f44          lsl     r20
000582 0f44          lsl     r20                         ; align current with state[7:6]
000583 1764          cp      r22, r20
000584 f0b1          breq    DebounceButtonsEnd          ; no change in the encoder state
                     ; brne  EncUpdateState
                 
                 EncUpdateState:
000585 9556          lsr     r21 
000586 9556          lsr     r21                         ; shift state to right to make room for new reading
000587 0f54          add     r21, r20
000588 9350 01bd     sts     rot_state, r21
                     ; rjmp    EncCheckCW
                 
                 EncCheckCW:
00058a 3d52          cpi     r21, ENC_CW_TURN
00058b f439          brne	EncCheckCCW
                     ; breq    SetRotCW
                 
                 SetRotCW:
00058c e031          ldi     r19, TRUE
00058d 9330 01be     sts     rot_cw, r19
00058f e050          ldi     r21, ENC_INIT_STATE
000590 9350 01bd     sts     rot_state, r21
000592 c008          rjmp	DebounceButtonsEnd
                 
                 EncCheckCCW:
000593 3e51          cpi     r21, ENC_CCW_TURN
000594 f431          brne	DebounceButtonsEnd
                     ; breq SetRotCCW
                 
                 SetRotCCW:
000595 e031          ldi     r19, TRUE
000596 9330 01bf     sts     rot_ccw, r19
000598 e050          ldi     r21, ENC_INIT_STATE
000599 9350 01bd     sts     rot_state, r21
                     ; rjmp  DebounceButtonsEnd
                 
                 DebounceButtonsEnd:
00059b 9508          ret
                 
                 
                 ; r19 - mask, r18 - current_t
                 ; return: r18 - current_t, r19 - pressed?
                 ;--------------------------------------------------------------
                 CheckBtn:
00059c b101          in      r16, BUTTON_DATA  ; r16 holds the current state of the buttons
00059d 2f10          mov     r17, r16     ; r17 holds the bits of interest
00059e 2313          and     r17, r19     ; mask the bits of interest
00059f f011          breq    BtnDown
                     ; brne  BtnUp
                 
                 BtnUp:
0005a0 e02a          ldi     r18, DEBOUNCE_T
0005a1 c004          rjmp    CheckBtnEnd
                 
                 BtnDown:
0005a2 952a          dec     r18
0005a3 f411          brne    CheckBtnEnd
                     ; breq  SetBtnPressed
                 
                 SetBtnPressed:
0005a4 e031          ldi     r19, TRUE
0005a5 ef2f          ldi     r18, AUTOREP_T
                     ; rjmp  CheckBtnEnd
                 
                 CheckBtnEnd:
0005a6 9508          ret
                 ;--------------------------------------------------------------


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega64" register use summary:
r0 :  68 r1 :   3 r2 :  11 r3 :   4 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16: 339 r17: 131 r18:  73 r19:  38 r20:  28 r21:  19 r22:  12 r23:   2 
r24:   2 r25:   2 r26:   9 r27:   9 r28:  18 r29:  18 r30:  18 r31:  18 
x  :   6 y  :  12 z  :  24 
Registers used: 23 out of 35 (65.7%)

"ATmega64" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  12 add   :  22 adiw  :   5 and   :   2 
andi  :  18 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   2 break :   0 breq  :  18 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   7 brlt  :   0 brmi  :   0 
brne  :  30 brpl  :   0 brsh  :   5 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   5 cbr   :   0 
clc   :   0 clh   :   0 cli   :  10 cln   :   0 clr   :  31 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  13 cpc   :   1 
cpi   :  26 cpse  :  14 dec   :  23 eor   :   1 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   2 in    :  16 inc   :  17 jmp   :  35 
ld    :   5 ldd   :   1 ldi   : 165 lds   :  69 lpm   :  22 lsl   :   7 
lsr   :   6 mov   :  17 movw  :   3 mul   :   0 muls  :   1 mulsu :   0 
neg   :   1 nop   :   0 or    :   7 ori   :   9 out   :  32 pop   :  27 
push  :  27 rcall : 121 ret   :  77 reti  :   2 rjmp  :  20 rol   :  12 
ror   :   0 sbc   :   1 sbci  :   1 sbi   :   3 sbic  :   0 sbis  :   1 
sbiw  :   1 sbr   :   0 sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :  11 std   :   0 sts   :  95 
sub   :   4 subi  :   1 swap  :   4 tst   :   2 wdr   :   0 
Instructions used: 58 out of 113 (51.3%)

"ATmega64" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b4e   2544    350   2894   65536   4.4%
[.dseg] 0x000100 0x0001c0      0    192    192    4096   4.7%
[.eseg] 0x000000 0x000000      0      0      0    2048   0.0%

Assembly complete, 0 errors, 0 warnings
